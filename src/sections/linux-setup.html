<section id="linux-setup" class="content-section">

    <h1>Rocky Linux 9 for EDA Server</h1>
    <p>단순한 OS 설치를 넘어, 수천만 원짜리 EDA 툴이 돌아가는 <strong>엔터프라이즈급 서버 구축 노하우</strong>를 공유합니다.</p>

    <h2>1. 리눅스 디렉토리 구조 기초</h2>
    <p>리눅스는 모든 것이 파일이며, 계층적 디렉토리 구조를 가집니다. EDA 서버를 관리하려면 <strong>어디에 무엇이 있는지</strong> 알아야 합니다.</p>

    <div class="note-box">
        <i data-lucide="folder-tree"></i>
        <div>
            <strong>핵심 개념:</strong><br>
            Windows의 <code>C:\Program Files</code>, <code>C:\Users</code>처럼, 리눅스도 용도별로 정해진 위치가 있습니다. 무작정 파일을 아무 곳에 저장하면
            나중에 찾기 어렵고, 시스템 업데이트 시 문제가 생길 수 있습니다.
        </div>
    </div>

    <h3>주요 디렉토리 용도 (FPGA 엔지니어 관점)</h3>
    <div style="overflow-x:auto; margin-top:15px;">
        <table style="width:100%; border-collapse:collapse; text-align:left; border:1px solid var(--border-color);">
            <thead>
                <tr style="background-color:var(--secondary-bg); border-bottom:2px solid var(--border-color);">
                    <th style="padding:12px; width:15%;">디렉토리</th>
                    <th style="padding:12px; width:35%;">용도</th>
                    <th style="padding:12px; width:50%;">FPGA 개발 연관성</th>
                </tr>
            </thead>
            <tbody style="font-size:0.95em;">
                <tr style="border-bottom:1px solid var(--border-color);">
                    <td style="padding:12px;"><code>/bin</code></td>
                    <td style="padding:12px;">필수 실행 파일 (ls, cp, rm 등)</td>
                    <td style="padding:12px; color:var(--text-secondary);">시스템 명령어. 건드릴 일 없음</td>
                </tr>
                <tr style="border-bottom:1px solid var(--border-color);">
                    <td style="padding:12px;"><code>/etc</code></td>
                    <td style="padding:12px;">시스템 설정 파일</td>
                    <td style="padding:12px;"><strong>중요!</strong> 네트워크, 방화벽, 라이센스 설정 위치</td>
                </tr>
                <tr style="border-bottom:1px solid var(--border-color);">
                    <td style="padding:12px;"><code>/home</code></td>
                    <td style="padding:12px;">사용자 개인 폴더</td>
                    <td style="padding:12px;"><strong>백업 1순위.</strong> 프로젝트 소스, 시뮬레이션 데이터</td>
                </tr>
                <tr style="border-bottom:1px solid var(--border-color);">
                    <td style="padding:12px;"><code>/opt</code></td>
                    <td style="padding:12px;">외부 소프트웨어 설치 권장 위치</td>
                    <td style="padding:12px;">EDA 툴 기본 설치 경로 (<code>/opt/Xilinx</code>)</td>
                </tr>
                <tr style="border-bottom:1px solid var(--border-color);">
                    <td style="padding:12px;"><code>/tmp</code></td>
                    <td style="padding:12px;">임시 파일 (재부팅 시 삭제됨)</td>
                    <td style="padding:12px;">시뮬레이션 중간 파일 (<code>vsim.wlf</code>) 등</td>
                </tr>
                <tr style="border-bottom:1px solid var(--border-color);">
                    <td style="padding:12px;"><code>/usr</code></td>
                    <td style="padding:12px;">시스템 공용 프로그램/라이브러리</td>
                    <td style="padding:12px;">패키지 관리자로 설치한 툴들 위치</td>
                </tr>
                <tr style="border-bottom:1px solid var(--border-color);">
                    <td style="padding:12px;"><code>/var</code></td>
                    <td style="padding:12px;">가변 데이터 (로그, 캐시)</td>
                    <td style="padding:12px;"><code>/var/log</code>: 시스템 에러 추적 시 확인</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="note-box" style="margin-top:20px;">
        <i data-lucide="alert-triangle"></i>
        <div>
            <strong>관례와 권장사항:</strong><br>
            - <strong>EDA 툴</strong>: <code>/opt</code> 또는 <code>/tools</code> (커스텀 디렉토리 생성)<br>
            - <strong>프로젝트 데이터</strong>: <code>/home/[사용자명]</code> 또는 <code>/data</code> (별도 파티션 권장)<br>
            - <strong>절대 금지</strong>: <code>/root</code>에 개인 작업 저장 (root 계정 전용이므로 권한 문제 발생)
        </div>
    </div>

    <h2>2. 파티션 및 파일시스템 전략</h2>
    <p>OS 재설치 시에도 데이터와 툴을 보호하기 위해 물리적/논리적 파티션 분리는 필수입니다.</p>
    <div class="shortcut-grid">
        <div class="shortcut-card">
            <span>/ (Root)</span>
            <span style="font-size: 0.9em; opacity: 0.8;">OS 시스템 영역. 50GB~100GB 권장.</span>
        </div>
        <div class="shortcut-card">
            <span>/tools</span>
            <span style="font-size: 0.9em; opacity: 0.8;">EDA 툴 설치 경로. OS와 완전히 분리 필수.</span>
        </div>
        <div class="shortcut-card">
            <span>/home</span>
            <span style="font-size: 0.9em; opacity: 0.8;">사용자 데이터. 백업 1순위.</span>
        </div>
        <div class="shortcut-card">
            <span>SWAP</span>
            <span style="font-size: 0.9em; opacity: 0.8;">PHY 합성 시 RAM 부족 대비. RAM 용량의 0.5배 이상.</span>
        </div>
    </div>

    <h3 style="margin-top:30px;">실전 팁: 별도 디스크 추가 및 마운트</h3>
    <p>프로덕션 환경에서는 <strong>OS 디스크와 데이터 디스크를 물리적으로 분리</strong>하는 것이 모범 사례입니다. OS 장애가 발생해도 EDA 툴과 프로젝트 데이터는 보호됩니다.</p>

    <div class="note-box">
        <i data-lucide="hard-drive"></i>
        <div>
            <strong>왜 별도 디스크를 사용하나요?</strong><br>
            • <strong>데이터 보호</strong>: OS 재설치 시에도 /tools, /home 데이터 안전<br>
            • <strong>성능 향상</strong>: OS와 시뮬레이션 I/O 경합 방지<br>
            • <strong>용량 확장</strong>: 나중에 디스크 추가만으로 쉽게 확장 가능
        </div>
    </div>

    <h4 style="margin-top:20px;">단계별 마운트 절차</h4>

    <div class="code-step">
        <div class="step-title">Step 1: 디스크 확인</div>
        <pre><code class="language-bash"># 연결된 디스크 목록 확인
lsblk

# 출력 예시:
# NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
# sda      8:0    0   500G  0 disk           ← OS 디스크
# ├─sda1   8:1    0   512M  0 part /boot/efi
# └─sda2   8:2    0   499G  0 part /
# sdb      8:16   0     2T  0 disk           ← 새로 추가한 디스크 (아직 파티션 없음)</code></pre>
    </div>

    <div class="code-step">
        <div class="step-title">Step 2: 파티션 생성 (선택사항)</div>
        <p style="margin-top:10px; color:var(--text-secondary); font-size:0.9em;">
            전체 디스크를 하나의 파티션으로 사용하는 경우가 일반적입니다. 아래는 GPT 파티션 테이블을 사용한 예시입니다.
        </p>
        <pre><code class="language-bash"># parted로 GPT 파티션 생성
sudo parted /dev/sdb

(parted) mklabel gpt                    # GPT 파티션 테이블 생성
(parted) mkpart primary ext4 0% 100%    # 전체 용량을 하나의 파티션으로
(parted) quit

# 결과 확인
lsblk
# sdb      8:16   0     2T  0 disk
# └─sdb1   8:17   0     2T  0 part   ← 생성된 파티션</code></pre>
    </div>

    <div class="code-step">
        <div class="step-title">Step 3: 파일시스템 생성</div>
        <pre><code class="language-bash"># ext4 파일시스템 생성 (대용량 데이터에 적합)
sudo mkfs.ext4 /dev/sdb1

# 레이블 지정 (선택사항, 나중에 식별하기 편함)
sudo e2label /dev/sdb1 EDA_DATA</code></pre>
    </div>

    <div class="code-step">
        <div class="step-title">Step 4: 마운트 포인트 생성 및 임시 마운트</div>
        <pre><code class="language-bash"># 마운트 포인트 디렉토리 생성
sudo mkdir -p /data

# 임시 마운트 (재부팅 시 사라짐)
sudo mount /dev/sdb1 /data

# 확인
df -h | grep data
# /dev/sdb1       2.0T   24K  1.9T   1% /data</code></pre>
    </div>

    <div class="code-step">
        <div class="step-title">Step 5: 영구 마운트 설정 (/etc/fstab)</div>
        <p style="margin-top:10px; color:var(--text-secondary); font-size:0.9em;">
            <strong>중요!</strong> fstab에 추가해야 재부팅 후에도 자동으로 마운트됩니다.
        </p>
        <pre><code class="language-bash"># 1. 디스크의 UUID 확인 (디바이스명보다 UUID 사용 권장)
sudo blkid /dev/sdb1

# 출력: /dev/sdb1: UUID="a1b2c3d4-..." TYPE="ext4" LABEL="EDA_DATA"

# 2. /etc/fstab 파일에 추가
sudo vi /etc/fstab

# 아래 내용 추가 (UUID는 실제 값으로 대체)
UUID=a1b2c3d4-...  /data  ext4  defaults,nofail  0  2
#                   │      │     │                │  │
#                   │      │     │                │  └─ fsck 순서 (0=체크안함, 1=루트, 2=기타)
#                   │      │     │                └─ dump 백업 여부 (0=안함, 1=함)
#                   │      │     └─ 마운트 옵션 (nofail: 실패해도 부팅 계속)
#                   │      └─ 파일시스템 타입
#                   └─ 마운트 포인트

# 3. 설정 테스트 (재부팅 없이 fstab 적용)
sudo mount -a

# 에러가 없으면 성공!</code></pre>
    </div>

    <div class="note-box" style="margin-top:20px;">
        <i data-lucide="alert-triangle"></i>
        <div>
            <strong>실전 예시: /tools와 /data 분리</strong><br>
            • 디스크 1 (500GB SSD): OS 전용 (/, /boot)<br>
            • 디스크 2 (2TB HDD): /tools 마운트 (EDA 툴 설치용)<br>
            • 디스크 3 (4TB HDD): /data 마운트 (프로젝트 데이터, 백업 1순위)<br>
            이렇게 구성하면 OS 문제가 생겨도 디스크 2, 3은 그대로 보존되며, 새 OS 설치 후 다시 마운트만 하면 즉시 작업 재개 가능합니다.
        </div>
    </div>

    <h2>3. 필수 의존성 패키지 (Ghost Libraries)</h2>
    <p>최신 OS(Rocky 9)에 이전 세대 EDA 툴을 설치할 때 발생하는 라이브러리 에러 해결책입니다.</p>
    <pre><code class="language-bash"># 1. EPEL 저장소 활성화
sudo dnf install -y epel-release

# 2. 필수 시스템 라이브러리 & 개발 툴
sudo dnf groupinstall -y "Development Tools"
sudo dnf install -y redhat-lsb-core git wget htop

# 3. EDA 툴 구동을 위한 Legacy 라이브러리 (Crucial!)
# libnsl: FlexLM 라이센스 데몬이 주로 사용
# libX*: Vivado/Questasim GUI 구동용
sudo dnf install -y libnsl libX11 libXext libXft libXtst \
    ncurses-compat-libs \
    libstdc++.i686 glibc.i686</code></pre>

    <div class="note-box">
        <i data-lucide="alert-triangle"></i>
        <div>
            <strong>주의: SELinux 및 방화벽</strong><br>
            FlexLM 라이센스 서버 통신 문제 해결을 위해, 내부망일 경우 SELinux는 <code>Permissive</code>로, 방화벽은 특정 포트(27000~27009)를 개방하거나
            비활성화해야
            할 수 있습니다.
        </div>
    </div>

    <h2>4. EDA 툴 설치 표준 절차</h2>
    <p>EDA 툴은 설치 위치와 권한 설정이 매우 중요합니다. 무턱대고 <code>root</code>로 설치하면 나중에 관리가 어려워집니다.</p>

    <h3>1단계: 설치 디렉토리 준비 (Root 권한 필요)</h3>
    <p>통상적으로 <code>/tools</code> 또는 <code>/opt</code>를 사용합니다. 폴더를 만들고 <strong>소유권을 관리자 계정(또는 본인)으로 변경</strong>해야 합니다.
    </p>
    <pre><code class="language-bash"># 1. 디렉토리 생성 (Root)
sudo mkdir -p /tools/Xilinx

# 2. 소유권 변경 (중요!)
# root가 아닌, 실제 설치를 진행할 사용자($USER)에게 권한을 줍니다.
sudo chown -R $USER:$USER /tools/Xilinx</code></pre>

    <h3>2단계: 설치 프로그램 실행 (GUI)</h3>
    <p>이제 <code>sudo</code> 없이 설치 프로그램을 실행합니다. 그래야 생성되는 파일들이 온전히 내 계정 소유가 됩니다.</p>
    <pre><code class="language-bash"># 설치 프로그램 실행 (sudo 사용 금지!)
./xsetup</code></pre>

    <h3>3단계: 설치 후 환경설정 고려사항</h3>
    <p>설치가 완료되면 벤더가 제공하는 설정 파일(예: <code>settings64.sh</code>) 위치를 파악해둡니다. 이 내용을 바탕으로 다음 섹션의 <strong>나만의 설정
            스크립트</strong>를 만듭니다.</p>

    <div class="note-box">
        <i data-lucide="users"></i>
        <div>
            <strong>Q: 특정 사용자로 설치하면 다른 사람은 못 쓰나요?</strong><br>
            아닙니다! 리눅스 디렉토리는 기본적으로 <strong>755 (drwxr-xr-x)</strong> 권한을 가집니다. 이는 소유자만 수정(Write)할 수 있고, 다른 사용자들은
            <strong>읽기
                및 실행(Read/Execute)</strong>이 가능하다는 뜻입니다. 따라서 설치는 특정 관리자 계정으로 진행하고, 사용은 모든 팀원이 문제없이 할 수 있습니다.
        </div>
    </div>

    <h2>5. 버전별 환경 설정 관리 (Shell Script 활용)</h2>
    <p>Environment Modules와 같은 도구는 설정이 복잡할 수 있습니다. 대신 <strong>버전별 설정 스크립트</strong>를 만들어 필요할 때만 <code>source</code> 하는
        방식이 훨씬 직관적입니다.</p>

    <h3>1. 설정 스크립트 작성 (예: ~/env_vivado_2023.sh)</h3>
    <pre><code class="language-bash">#!/bin/bash
# 2023 버전 경로를 PATH의 맨 앞에 추가(Prepend)
export XILINX_VIVADO=/tools/Xilinx/Vivado/2023.2
export PATH=$XILINX_VIVADO/bin:$PATH

echo "Vivado 2023.2 환경이 로드되었습니다."</code></pre>

    <h3>2. 환경변수 적용 (Source)</h3>
    <p>스크립트를 실행(<code>./Example.sh</code>)하면 자식 쉘에서만 적용되고 사라집니다. 반드시 <strong>source</strong> 명령어로 현재 쉘에 적용해야 합니다.</p>
    <pre><code class="language-bash">source ~/env_vivado_2023.sh</code></pre>

    <div class="note-box">
        <i data-lucide="help-circle"></i>
        <div>
            <strong>자주 묻는 질문: PATH가 계속 쌓이지 않나요?</strong><br>
            맞습니다. 여러 버전을 계속 source 하면 PATH 변수가 길어집니다.
            하지만 위 스크립트는 경로를 <strong>맨 앞($PATH 왼쪽)</strong>에 붙이기 때문에, 시스템은 항상 <strong>가장 최근에 로드한 버전의 명령어</strong>를 우선적으로
            찾습니다.
            따라서 기능상 충돌 없이 정상 작동합니다.
        </div>
    </div>

    <h3>3. 편의성 팁 (Alias 설정)</h3>
    <p>매번 긴 경로를 입력하기 귀찮다면 <code>.bashrc</code>에 단축어를 등록하세요.</p>
    <pre><code class="language-bash"># ~/.bashrc 파일 하단에 추가
alias v2023='source ~/env_vivado_2023.sh'
alias v2024='source ~/env_vivado_2024.sh'</code></pre>

    <h2>6. 다중 사용자 권한 관리 (협업의 핵심)</h2>
    <p>여러 엔지니어가 하나의 프로젝트 폴더를 공유할 때, <strong>"동료가 만든 파일을 수정할 수 없는 문제(Permission Denied)"</strong>가 반드시 발생합니다. 매번
        <code>chmod 777</code>을 하는 것은 보안상 최악입니다.
    </p>
    <p>관리자가 개입하지 않아도 팀원끼리 자유롭게 파일을 수정할 수 있는 <strong>3단계 표준 절차</strong>를 예시와 함께 설명합니다.</p>

    <h3>1. 문제 상황 (Scenario)</h3>
    <p>엔지니어 A와 B가 같은 팀이지만, A가 만든 파일을 B가 수정하려고 하면 <strong>"권한 없음"</strong> 에러가 뜹니다. 이는 리눅스의 기본 설정이 "본인만 수정 가능"하기 때문입니다.
    </p>

    <h3>2. 해결책: SetGID와 Umask 콤보</h3>
    <div class="shortcut-grid">
        <div class="shortcut-card" style="flex-direction: column; align-items: flex-start; white-space: normal;">
            <strong style="margin-bottom: 8px; color: var(--accent-color);">1. SetGID (g+s) 설정</strong>
            <span style="font-size: 0.9em; opacity: 0.8; line-height: 1.5;">"이 폴더 안에 생기는 모든 파일은 <strong>자동으로 팀 그룹
                    소유</strong>가 된다."<br>(작성자의 개인 그룹이 아님)</span>
        </div>
        <div class="shortcut-card" style="flex-direction: column; align-items: flex-start; white-space: normal;">
            <strong style="margin-bottom: 8px; color: var(--accent-color);">2. Umask 002 설정</strong>
            <span style="font-size: 0.9em; opacity: 0.8; line-height: 1.5;">"파일을 만들 때 <strong>같은 팀원에게도 수정(쓰기)
                    권한</strong>을
                준다."<br>(기본값은 읽기만 가능)</span>
        </div>
    </div>

    <h3 style="margin-top: 20px;">3. 따라해보기 (Best Practice)</h3>
    <pre><code class="language-bash"># [관리자] 1. 프로젝트 폴더 생성 및 그룹 지정
sudo mkdir /data/project_X
sudo chown root:eda_users /data/project_X

# [관리자] 2. 핵심! SetGID 비트 설정
# g+s를 하면 그룹 권한 자리에 's'가 생깁니다 (drwxr-sr-x)
sudo chmod g+s /data/project_X

# [사용자] 3. Umask 설정을 .bashrc에 추가
# "내가 만드는 파일은 팀원도 수정할 수 있게(rw-rw-r--) 해주세요"
echo "umask 002" >> ~/.bashrc</code></pre>

    <div class="note-box">
        <i data-lucide="check-circle"></i>
        <div>
            <strong>결과:</strong><br>
            이제 엔지니어 A가 파일을 생성해도, 소유 그룹은 자동으로 <code>eda_users</code>가 되고 권한은 <code>rw-</code>(쓰기 가능)로 설정됩니다. 엔지니어 B는 자유롭게
            수정할 수 있습니다.
        </div>
    </div>
</section>