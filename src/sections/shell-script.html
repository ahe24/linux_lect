<section id="shell-script" class="content-section">
    <h1>Shell Scripting for EDA (Automation)</h1>
    <p>반복적인 작업(컴파일, 로그 분석, 파일 정리)을 자동화하여 퇴근 시간을 1시간 앞당기는 <strong>실전 쉘 스크립트 기법</strong>입니다.</p>

    <!-- 1. Log Analysis -->
    <h2>1. 시뮬레이션 로그 한방에 분석하기</h2>
    <p>FPGA 합성이나 시뮬레이션 결과가 담긴 수십 개의 로그 파일에서 <strong>특정 정보(Error, Warning, Timing Info)</strong>만 빠르게 뽑아내는 기법입니다.</p>

    <div class="code-snippet-box">
        <span class="code-snippet-title">📜 check_logs.sh (로그 분석 스크립트 예시)</span>
        <pre><code class="language-bash">#!/bin/bash
# 사용법: ./check_logs.sh [로그폴더위치]

TARGET_DIR=${1:-.} # 인자가 없으면 현재 디렉토리 점검

echo "🔍 Checking logs in: $TARGET_DIR"

# 1. Error가 있는 로그 파일 찾기
# -l: 파일명만 출력, -i: 대소문자 무시
grep -li "error" "$TARGET_DIR"/*.log > error_files.txt

# -s: 파일 크기가 0보다 크면 참 (즉, 에러 파일이 하나라도 발견됨)
if [ -s error_files.txt ]; then
    echo "❌ Errors found in the following files:"
    cat error_files.txt
else
    echo "✅ No errors found!"
fi

# 2. Timing Report에서 Slack 값 추출 (Vivado 예시)
# "Worst Negative Slack (WNS): -0.450 ns" -> "-0.450" 추출
IMPL_LOG="$TARGET_DIR/impl.log"

# -f: 파일이 실제로 존재하면 참
if [ -f "$IMPL_LOG" ]; then
    slack=$(grep "Worst Negative Slack" "$IMPL_LOG" | awk '{print $5}')
    echo "⏱️ Timing Slack: ${slack}ns"
fi</code></pre>
    </div>

    <!-- 2. Advanced Search -->
    <h2>2. 프로젝트 전체 키워드 검색</h2>
    <p>수백 개의 소스코드 파일 중에서 <strong>특정 신호 이름</strong>이나 <strong>모듈 사용 위치</strong>를 순식간에 찾아냅니다.</p>

    <div class="code-snippet-box">
        <span class="code-snippet-title">🔎 find_code.sh</span>
        <pre><code class="language-bash">#!/bin/bash
# 사용법: ./find_code.sh [검색어] [확장자(옵션)]
# 예시 1: ./find_code.sh "axi_wdata"       -> 모든 파일에서 검색
# 예시 2: ./find_code.sh "module" "v"      -> .v 파일에서만 검색

KEYWORD=$1
EXT=${2:-*} # 두 번째 인자가 없으면 모든 파일(*) 검색

# -z: 문자열 길이가 0이면 참 (즉, 키워드가 비어있음)
if [ -z "$KEYWORD" ]; then
    echo "Usage: ./find_code.sh [KEYWORD] [EXTENSION(Optional)]"
    exit 1
fi

echo "🔎 Searching for '$KEYWORD' in '*.$EXT' recursively..."

# -r: 하위 폴더까지 재귀 검색
# -n: 라인 번호 출력
# --include: 특정 확장자만 검색
# --color: 검색어 강조
grep -rn "$KEYWORD" --include="*.$EXT" . --color=auto</code></pre>
    </div>

    <!-- 4. Text Processing -->
    <h2>3. 텍스트 일괄 치환 (sed 자동화)</h2>
    <p>수백 개의 Verilog 파일에서 모듈 이름을 바꾸거나 특정 파라미터를 변경해야 할 때 유용합니다.</p>

    <div class="code-snippet-box">
        <span class="code-snippet-title">✏️ replace_text.sh</span>
        <pre><code class="language-bash">#!/bin/bash
# 사용법: ./replace_text.sh [찾을단어] [바꿀단어] [파일확장자(기본:*.v)]

OLD=$1
NEW=$2
FILES=${3:-*.v} # 3번째 인자가 없으면 .v 파일 전체 대상

if [ -z "$OLD" ] || [ -z "$NEW" ]; then
    echo "Usage: ./replace_text.sh [OLD_STRING] [NEW_STRING] [FILE_PATTERN]"
    exit 1
fi

echo "✏️ Replacing '$OLD' with '$NEW' in $FILES..."

# sed -i : 원본 파일 덮어쓰기
# s/A/B/g : A를 B로 모두(global) 치환
sed -i "s/$OLD/$NEW/g" $FILES

echo "✅ Done."</code></pre>
    </div>

    <!-- 5. File List Generation -->
    <h2>4. 파일 목록(.f) 자동 생성기</h2>
    <p><code>sim</code> 폴더에서 실행하면, 상위의 <code>rtl</code>, <code>tb</code> 폴더를 뒤져서 시뮬레이션용 파일 목록을 만들어줍니다.</p>
    <div class="code-snippet-box">
        <span class="code-snippet-title">📂 gen_filelist.sh</span>
        <pre><code class="language-bash">#!/bin/bash
# 시뮬레이션용 .f 파일 생성 스크립트
# 실행 위치: sim/ 폴더

OUT_FILE="filelist.f"
SEARCH_DIRS="../rtl ../tb" # 검색할 상위 폴더들 (상대경로)

echo "Generating $OUT_FILE from $SEARCH_DIRS ..."

# 1. 기존 파일 초기화 및 헤더 작성
echo "// Auto-generated by gen_filelist.sh on $(date)" > $OUT_FILE
echo "+incdir+../rtl/include" >> $OUT_FILE # include 경로는 필요 시 수정

# 2. find 명령어로 .v, .sv 파일 찾기
# -type f : 파일만 찾기
# \( ... \) : 조건 그룹핑 (OR 조건)
find $SEARCH_DIRS -type f \( -name "*.v" -o -name "*.sv" \) >> $OUT_FILE

# 3. 결과 요약
COUNT=$(wc -l < $OUT_FILE)
echo "✅ Done! Added $COUNT files to $OUT_FILE"
echo "   (Check content: cat $OUT_FILE)"</code></pre>
    </div>

    <!-- 5. FlexLM License Check -->
    <h2>5. FlexLM 라이센스 상태 체크</h2>
    <p>Siemens 등 EDA 툴의 라이센스 서버(FlexLM) 상태를 확인하고, 누가 라이센스를 점유하고 있는지 추적합니다.</p>
    <div class="code-snippet-box">
        <span class="code-snippet-title">🔑 check_license.sh</span>
        <pre><code class="language-bash">#!/bin/bash
# 사용법: ./check_license.sh [FeatureName]
# 예시 1: ./check_license.sh          -> 전체 라이센스 현황 요약
# 예시 2: ./check_license.sh msim     -> 'msim' 기능 사용자 추적

# 1. 라이센스 서버 주소 (환경변수가 없으면 기본값 사용)
# ${VAR:-DEFAULT} : VAR가 비어있으면 DEFAULT 값 사용
LIC_SERVER=${SALT_LICENSE_SERVER:-"1717@ednc-net.iptime.org"}

# FlexLM 유틸리티 경로 (시스템에 따라 수정 필요)
LMUTIL="lmutil" 

echo "🔍 Checking License Server: $LIC_SERVER"

if [ -z "$1" ]; then
    # 인자가 없으면: 전체 라이센스 "Users of" 라인만 요약 출력
    # awk로 Feature 이름과 사용량만 깔끔하게 정리
    $LMUTIL lmstat -a -c "$LIC_SERVER" | grep "Users of" | \
    sed 's/Users of //g' | awk '{printf "%-20s : Total %s, Used %s\n", $1, $6, $11}'
else
    # 인자가 있으면: 특정 Feature의 상세 사용자 정보 출력
    FEATURE=$1
    echo "📋 Detailed info for '$FEATURE':"
    $LMUTIL lmstat -f "$FEATURE" -c "$LIC_SERVER"
fi</code></pre>
    </div>

</section>