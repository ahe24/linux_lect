<section id="fpga-workflow" class="content-section">

    <h1>FPGA Workflow</h1>
    <p>FPGA/ASIC 개발의 핵심은 <strong>설계-검증-합성-구현</strong> 사이클을 효율적으로 반복하는 것입니다. 이 섹션에서는 Makefile과 스크립트를 활용한 <strong>재현
            가능한(Reproducible) 빌드 자동화</strong>를 다룹니다.</p>

    <h2>FPGA 개발 워크플로우</h2>
    <p>전형적인 FPGA 프로젝트는 다음 단계를 거칩니다. 각 단계를 CLI(Command-Line Interface) 기반으로 자동화하면 반복 작업 시간을 극적으로 단축할 수 있습니다.</p>

    <div style="background: linear-gradient(135deg, rgba(88,166,255,0.1) 0%, rgba(163,113,247,0.1) 100%); 
                border: 1px solid var(--border-color); 
                border-radius: 12px; 
                padding: 25px; 
                margin: 30px 0;">
        <!-- Row 1: Spec → RTL/TB → Functional Sim → Synthesis -->
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 18px; margin-bottom: 20px;">
            <!-- Step 1: Design Spec -->
            <div style="background: var(--panel-color); 
                        border: 2px solid #8b5cf6; 
                        border-radius: 8px; 
                        padding: 16px; 
                        text-align: left;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <span style="font-size: 2rem;">📋</span>
                    <span style="color: #8b5cf6; font-weight: bold; font-size: 1.05rem;">1. Design Spec</span>
                </div>
                <div style="font-size: 0.88rem; color: var(--text-secondary); padding-left: 0px;">요구사항 정의</div>
            </div>

            <!-- Step 2: RTL & Testbench -->
            <div style="background: var(--panel-color); 
                        border: 2px solid #58a6ff; 
                        border-radius: 8px; 
                        padding: 16px; 
                        text-align: left;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <span style="font-size: 2rem;">✍️</span>
                    <span style="color: #58a6ff; font-weight: bold; font-size: 1.05rem;">2. RTL & TB</span>
                </div>
                <div style="font-size: 0.88rem; color: var(--text-secondary); padding-left: 0px;">Verilog 코드 작성</div>
            </div>

            <!-- Step 3: Functional Simulation -->
            <div style="background: var(--panel-color); 
                        border: 2px solid #2ea043; 
                        border-radius: 8px; 
                        padding: 16px; 
                        text-align: left;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <span style="font-size: 2rem;">🔬</span>
                    <span style="color: #2ea043; font-weight: bold; font-size: 1.05rem;">3. Functional Sim</span>
                </div>
                <div style="font-size: 0.88rem; color: var(--text-secondary); padding-left: 0px;">RTL 기능 검증</div>
            </div>

            <!-- Step 4: Synthesis -->
            <div style="background: var(--panel-color); 
                        border: 2px solid #d29922; 
                        border-radius: 8px; 
                        padding: 16px; 
                        text-align: left;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <span style="font-size: 2rem;">⚙️</span>
                    <span style="color: #d29922; font-weight: bold; font-size: 1.05rem;">4. Synthesis</span>
                </div>
                <div style="font-size: 0.88rem; color: var(--text-secondary); padding-left: 0px;">논리 합성</div>
            </div>
        </div>

        <!-- Vertical Arrow Down -->
        <div
            style="text-align: center; color: var(--accent-color); font-size: 1.8rem; margin: 12px 0; font-weight: bold;">
            ↓
        </div>

        <!-- Row 2: Post-Syn Sim → P&R → Timing Sim → Bitstream/Test -->
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 18px;">
            <!-- Step 5: Post-Synthesis Simulation -->
            <div style="background: var(--panel-color); 
                        border: 2px solid #06b6d4; 
                        border-radius: 8px; 
                        padding: 16px; 
                        text-align: left;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <span style="font-size: 2rem;">🧪</span>
                    <span style="color: #06b6d4; font-weight: bold; font-size: 1.05rem;">5. Post-Syn Sim</span>
                </div>
                <div style="font-size: 0.88rem; color: var(--text-secondary); padding-left: 0px;">합성 후 시뮬레이션</div>
            </div>

            <!-- Step 6: Implementation (P&R) -->
            <div style="background: var(--panel-color); 
                        border: 2px solid #a371f7; 
                        border-radius: 8px; 
                        padding: 16px; 
                        text-align: left;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <span style="font-size: 2rem;">🗺️</span>
                    <span style="color: #a371f7; font-weight: bold; font-size: 1.05rem;">6. P&R</span>
                </div>
                <div style="font-size: 0.88rem; color: var(--text-secondary); padding-left: 0px;">Place & Route</div>
            </div>

            <!-- Step 7: Post-Route Timing Sim -->
            <div style="background: var(--panel-color); 
                        border: 2px solid #ec4899; 
                        border-radius: 8px; 
                        padding: 16px; 
                        text-align: left;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <span style="font-size: 2rem;">⏱️</span>
                    <span style="color: #ec4899; font-weight: bold; font-size: 1.05rem;">7. Timing Sim</span>
                </div>
                <div style="font-size: 0.88rem; color: var(--text-secondary); padding-left: 0px;">타이밍 검증</div>
            </div>

            <!-- Step 8: Bitstream & Testing -->
            <div style="background: var(--panel-color); 
                        border: 2px solid #10b981; 
                        border-radius: 8px; 
                        padding: 16px; 
                        text-align: left;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <span style="font-size: 2rem;">🎯</span>
                    <span style="color: #10b981; font-weight: bold; font-size: 1.05rem;">8. Bitstream & Test</span>
                </div>
                <div style="font-size: 0.88rem; color: var(--text-secondary); padding-left: 0px;">FPGA 보드 테스트</div>
            </div>
        </div>
    </div>

    <!-- Makefile Automation Highlight -->
    <div style="margin-top: 30px; 
                    padding: 20px; 
                    background: rgba(88,166,255,0.1); 
                    border-left: 4px solid var(--accent-color); 
                    border-radius: 6px;">
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
            <span style="font-size: 1.5rem;">🔧</span>
            <strong style="color: var(--accent-color); font-size: 1.1rem;">Makefile 자동화의 핵심 가치</strong>
        </div>
        <ul style="margin-left: 20px; line-height: 1.8; color: var(--text-secondary);">
            <li><strong>재현성 보장</strong>: 동일한 명령어로 누구나 같은 결과를 얻을 수 있습니다</li>
            <li><strong>반복 작업 제거</strong>: 10줄 명령어 → <code>make sim</code> 한 줄로 단축</li>
            <li><strong>의존성 관리</strong>: 변경된 파일만 재컴파일하여 시간 절감</li>
            <li><strong>CI/CD 통합</strong>: Jenkins, GitLab CI에서 배치 모드 실행 가능</li>
        </ul>
    </div>
    </div>

    <h2 class="break-before">1. Makefile이란? (초보자 필독)</h2>
    <p><strong>Makefile</strong>은 여러 명령어를 하나의 단축키처럼 묶어 실행하는 자동화 도구입니다. GUI 없이 터미널에서 복잡한 시뮬레이션을 제어할 때 필수입니다.</p>

    <div class="note-box">
        <i data-lucide="lightbulb"></i>
        <div>
            <strong>왜 필요한가요?</strong><br>
            시뮬레이션 한 번 돌리려면 보통 5~10개 명령어를 순서대로 입력해야 합니다. Makefile을 쓰면 <code>make sim</code> 단 한 줄로 모든 작업이 자동 실행됩니다.
        </div>
    </div>

    <h3>핵심 구조 (Target과 Dependencies)</h3>
    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:20px; margin-bottom:20px;">
        <div class="syntax-card" style="border-left-color: var(--vim-green);">
            <strong style="color:var(--vim-green); font-size:1.1em;">1. Target (목표 작업 정의)</strong>
            <p style="margin-top:10px; color:var(--text-secondary);">실행하고 싶은 작업의 이름과 실제 명령어를 정의합니다.</p>
            <pre style="margin-top:10px;"><code class="language-makefile"># 컴파일 작업
compile:
	vlib work
	vlog top.v tb.v

# 시뮬레이션 실행
sim:
	vsim -c work.tb -do "run -all"

# 정리 작업
clean:
	rm -rf work *.log</code></pre>
        </div>
        <div class="syntax-card" style="border-left-color: #ff6b6b;">
            <strong style="color:#ff6b6b; font-size:1.1em;">2. Dependencies (의존성 활용)</strong>
            <p style="margin-top:10px; color:var(--text-secondary);">콜론(:) 뒤에 먼저 실행되어야 할 작업을 명시합니다.</p>
            <pre style="margin-top:10px;"><code class="language-makefile"># sim 실행 전 compile 자동 실행
sim: compile
	vsim -do "run -all"

# all은 모든 단계 순차 실행
all: clean compile sim</code></pre>
            <div
                style="margin-top:10px; padding:10px; background:rgba(88,166,255,0.1); border-radius:4px; font-size:0.9em;">
                💡 <code>make sim</code> 입력 시:<br>
                1. compile 먼저 실행<br>
                2. 완료 후 sim 실행
            </div>
        </div>
    </div>

    <h3>꼭 알아야 할 문법 규칙</h3>
    <div class="note-box">
        <i data-lucide="alert-circle"></i>
        <div>
            <strong>⚠️ TAB 문자 필수!</strong><br>
            명령어 앞에는 반드시 <strong>TAB</strong> 문자(스페이스 아님)가 있어야 합니다. 스페이스로 들여쓰기하면 에러가 발생합니다.
            <pre style="margin-top:10px; background:rgba(0,0,0,0.3); padding:10px;"><code class="language-makefile">clean:
	rm -rf work
↑
이 부분이 TAB 문자여야 함!</code></pre>
        </div>
    </div>

    <h3>간단한 예시로 이해하기</h3>
    <div style="display:flex; gap:20px; flex-wrap:wrap; margin-bottom:30px;">
        <div style="flex:1; min-width:300px;">
            <h4 style="margin-top:0; color:var(--text-secondary); font-size:1rem;">문제 상황 (수동 실행)</h4>
            <pre><code class="language-bash"># 매번 이렇게 4줄을 타이핑해야 함
vlib work
vlog top.v
vlog tb.v
vsim -c work.tb -do "run -all"</code></pre>
        </div>
        <div style="flex:1; min-width:300px;">
            <h4 style="margin-top:0; color:var(--vim-green); font-size:1rem;">해결책 (Makefile)</h4>
            <pre><code class="language-makefile">sim:
	vlib work
	vlog top.v
	vlog tb.v
	vsim -c work.tb -do "run -all"</code></pre>
            <p style="margin-top:10px; color:var(--text-secondary); font-size:0.9em;">이제 터미널에서 <code>make sim</code> 한
                줄만 입력하면 끝!</p>
        </div>
    </div>

    <h2>2. Questasim Makefile 소개</h2>
    <p>단순히 복사해서 쓰는 것이 아니라, 각 명령어의 의미를 이해해야 에러를 잡을 수 있습니다.</p>

    <div class="note-box">
        <i data-lucide="book-open"></i>
        <div>
            <strong>핵심 명령어 설명:</strong>
            <ul style="list-style: disc; margin-left: 20px; margin-top: 10px;">
                <li><code>vlib work</code>: 컴파일된 디자인 유닛들이 저장될 물리적인 디렉토리를 생성합니다.</li>
                <li><code>vmap work work</code>: 논리적인 라이브러리 이름(work)을 물리적 디렉토리에 매핑합니다.</li>
                <li><code>vlog</code>: Verilog/SystemVerilog 컴파일러. <code>+incdir+</code> 옵션으로 헤더 파일 경로를 지정하는 것이 필수입니다.
                </li>
                <li><code>vopt</code>: <strong>Visualizer 최적화</strong>. <code>-o opt -debug +designfile</code> 옵션으로 디버그
                    정보가
                    포함된 최적화 객체를 생성합니다.</li>
                <li><code>vsim</code>: <code>-qwavedb=+signal</code> 옵션을 사용하여 Visualizer용 고속 시뮬레이션 DB를 생성합니다.</li>
            </ul>
        </div>
    </div>

    <pre><code class="language-makefile"># Makefile for Questasim (Visualizer Flow)
RTL_DIR = ../src
TB_DIR  = ../tb
WORK    = work
RTL_LIST = ../sim/run.f
TOP     = tb_top
OPT     = opt

# Visualizer GUI Live Simulation (with QWaveDB)
gui: clean compiled optimize
	vsim $(OPT) -visualizer -qwavedb=+signal -do "run 10 us"

# Batch / Post simulation mode
sim: clean compiled optimize
	vsim -batch $(OPT) -qwavedb=+signal -do "run -all; quit"

optimize:
	# vopt: Optimize & Debug options (+designfile for Visualizer)
	vopt $(WORK).$(TOP) -o $(OPT) -debug +designfile -L $(WORK)

compiled:
	vlib $(WORK)
	vmap work $(WORK)
	vlog -work $(WORK) +incdir+$(RTL_DIR) -f $(RTL_LIST)
	vlog -work $(WORK) +incdir+$(TB_DIR) $(TB_DIR)/$(TOP).v

# load wave database for visualizer
wave: 
	vis design.bin qwave.db &

clean:
	rm -rf $(WORK) transcript vsim.wlf qwave.db visualizer.log</code></pre>

    <div class="note-box">
        <i data-lucide="file-text"></i>
        <div>
            <strong>run.f 파일 예시:</strong><br />
            와일드카드(*.v)는 파일 로드 순서를 보장하지 않습니다. 상위 모듈이 하위 모듈보다 먼저 오지 않도록, 파일 리스트에서 의존성 순서대로 명시하는 것이 정석입니다.
            <pre><code class="language-plaintext" style="margin-top: 10px; background: #000; padding: 10px;">// 주석 가능
../src/defines.v
../src/alu.v
../src/cpu_top.v
</code></pre>
        </div>
    </div>

    <h2>3. Vivado 배포/합성 자동화 (Batch Mode)</h2>
    <p>Vivado에서도 파일 리스트(sources.f)를 Tcl로 파싱하여 관리하는 것이 유지보수에 좋습니다.</p>
    <pre><code class="language-makefile"># Makefile for Vivado
bitstream: 
	vivado -mode batch -source run_synth.tcl</code></pre>

    <h3>예시: run_synth.tcl (파일 리스트 + IP + Include 경로)</h3>
    <pre><code class="language-tcl"># run_synth.tcl
create_project -in_memory -part xc7a35ticsg324-1L

# Verilog Include 경로 설정 (헤더 파일이 있는 디렉토리)
set_property include_dirs {../src/include ../ip/include} [current_fileset]

# 파일 리스트 읽기 함수
set fp [open "sources.f" r]
set file_data [read $fp]
close $fp

# 라인별로 읽어서 파일 형식에 맞게 처리
foreach line [split $file_data "\n"] {
    # 빈 줄이나 주석(#) 제외
    if {[string length $line] > 0 && ![string match "#*" $line]} {
        # 파일 확장자에 따라 다른 명령어 사용
        if {[string match "*.xci" $line]} {
            # Xilinx IP 파일 (.xci)
            read_ip $line
        } elseif {[string match "*.vhd" $line] || [string match "*.vhdl" $line]} {
            # VHDL 파일
            read_vhdl $line
        } elseif {[string match "*.v" $line] || [string match "*.sv" $line]} {
            # Verilog/SystemVerilog 파일
            read_verilog $line
        }
    }
}

read_xdc ../const/pins.xdc

synth_design -top top_module -part xc7a35ticsg324-1L
opt_design
place_design
route_design
write_bitstream -force ./build_output/final.bit</code></pre>

    <div class="note-box">
        <i data-lucide="lightbulb"></i>
        <div>
            <strong>sources.f 파일 예시 (Verilog + VHDL + IP 혼합):</strong><br>
            다양한 파일 형식을 하나의 리스트로 관리할 수 있습니다.
            <pre style="margin-top:10px; background:rgba(0,0,0,0.3); padding:10px;"><code class="language-plaintext"># Verilog RTL
../src/defines.v
../src/alu.v

# SystemVerilog
../src/cpu_top.sv

# VHDL 서드파티 IP (예: 암호화 모듈)
../src/crypto/aes_core.vhd

# Xilinx IP Cores
../ip/clk_wiz_0/clk_wiz_0.xci
../ip/fifo_generator_0/fifo_generator_0.xci</code></pre>
        </div>
    </div>

    <div class="note-box">
        <i data-lucide="info"></i>
        <div>
            <strong>Include 경로 설정 이유:</strong><br>
            Verilog 코드에서 <code>`include "config.vh"</code> 같은 헤더 파일을 사용할 때, 합성 툴이 해당 파일을 찾을 수 있도록 경로를 명시해야 합니다.
            <code>set_property include_dirs</code>로 여러 디렉토리를 지정하면 자동으로 검색됩니다.
        </div>
    </div>
</section>