<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FPGA Linux & VIM Master Class</title>
  <link rel="stylesheet" href="./style.css" />
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=JetBrains+Mono:wght@400;700&display=swap"
    rel="stylesheet">
  <!-- Highlight.js Theme -->
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark-dimmed.min.css">
</head>

<body>
  <!-- Mobile Menu Toggle -->
  <button id="menu-toggle" aria-label="Toggle Menu">
    <i data-lucide="menu"></i>
  </button>

  <aside>
    <div class="brand">
      <i data-lucide="cpu"></i>
      <span>FPGA.env</span>
    </div>
    <nav>
      <ul>
        <li class="nav-item active" data-target="home">
          <i data-lucide="home"></i> Home
        </li>
        <li class="nav-item" data-target="distro-compare">
          <i data-lucide="scale"></i> Distro Comparison
        </li>
        <li class="nav-item" data-target="linux-setup">
          <i data-lucide="terminal-square"></i> Rocky 9 Setup
        </li>
        <li class="nav-item" data-target="server-ops">
          <i data-lucide="server"></i> Server Ops
        </li>
        <li class="nav-item" data-target="vim-mastery">
          <i data-lucide="pencil-ruler"></i> VIM Mastery
        </li>
        <li class="nav-item" data-target="fpga-workflow">
          <i data-lucide="workflow"></i> FPGA Simulation Workflow
        </li>
      </ul>
    </nav>
  </aside>

  <main>
    <!-- HOME SECTION -->
    <section id="home" class="content-section active">
      <h1>FPGA 엔지니어를 위한 Linux & VIM</h1>
      <p>환영합니다. 이 가이드는 FPGA 개발을 위한 최적의 리눅스 환경 구축과 VIM 에디터 활용법을 다룹니다.</p>

      <div class="note-box">
        <i data-lucide="info"></i>
        <div>
          <strong>왜 리눅스인가요?</strong><br />
          EDA 툴(Vivado, Questasim, Quartus)은 리눅스 환경에서 최고의 안정성과 성능을 발휘합니다. 특히 대규모 시뮬레이션과 서버 기반의 워크플로우는 리눅스 지식을 필수로 요구합니다.
        </div>
      </div>

      <h2>커리큘럼 개요</h2>
      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>Rocky Linux 9 환경 구축</span>
          <i data-lucide="check-circle" style="color: var(--accent-color)"></i>
        </div>
        <div class="shortcut-card">
          <span>사용자 및 데이터 권한 관리</span>
          <i data-lucide="check-circle" style="color: var(--accent-color)"></i>
        </div>
        <div class="shortcut-card">
          <span>VIM Mastery (Pro Level)</span>
          <i data-lucide="check-circle" style="color: var(--accent-color)"></i>
        </div>
        <div class="shortcut-card">
          <span>FPGA Simulation Workflow</span>
          <i data-lucide="check-circle" style="color: var(--accent-color)"></i>
        </div>
      </div>
    </section>

    <!-- DISTRO COMPARISON SECTION -->
    <section id="distro-compare" class="content-section">
      <h1>Red Hat vs Debian</h1>
      <p>리눅스 생태계의 양대 산맥인 Red Hat 계열과 Debian 계열의 차이를 명확히 이해하고, 목적에 맞는 OS를 선택하는 것이 중요합니다.</p>

      <h2>1. 주요 계열 비교 (RHEL vs Debian)</h2>
      <div class="note-box">
        <i data-lucide="info"></i>
        <div>
          <strong>핵심 요약:</strong> 수천 개의 배포판이 있지만, 엔터프라이즈 환경은 <strong>RHEL(Red Hat)</strong>, 사용자 및 개발자 환경은
          <strong>Debian/Ubuntu</strong>가 주도합니다.
        </div>
      </div>

      <div style="margin-top: 20px; overflow-x: auto;">
        <table style="width: 100%; border-collapse: collapse; text-align: left; border: 1px solid var(--border-color);">
          <thead>
            <tr style="background-color: var(--secondary-bg); border-bottom: 2px solid var(--border-color);">
              <th style="padding: 12px; font-weight: 600;">구분</th>
              <th style="padding: 12px; font-weight: 600; color: #ff6b6b;">Red Hat (RHEL) 계열</th>
              <th style="padding: 12px; font-weight: 600; color: #4ecdc4;">Debian 계열</th>
            </tr>
          </thead>
          <tbody>
            <tr style="border-bottom: 1px solid var(--border-color);">
              <td style="padding: 12px; font-weight: 600;">주요 배포판</td>
              <td style="padding: 12px;">RHEL, CentOS, Rocky, Fedora</td>
              <td style="padding: 12px;">Ubuntu, Debian, Kali, Mint</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border-color);">
              <td style="padding: 12px; font-weight: 600;">패키지 포맷</td>
              <td style="padding: 12px;">.rpm</td>
              <td style="padding: 12px;">.deb</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border-color);">
              <td style="padding: 12px; font-weight: 600;">패키지 관리자</td>
              <td style="padding: 12px;">yum, dnf</td>
              <td style="padding: 12px;">apt, apt-get</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border-color);">
              <td style="padding: 12px; font-weight: 600;">특징 & 철학</td>
              <td style="padding: 12px;">보수적 업데이트, 강력한 보안/안정성,<br>기업용 서버 표준</td>
              <td style="padding: 12px;">빠른 업데이트, 방대한 패키지,<br>개발자/데스크탑 친화적</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h2>2. 필수 명령어 차이점</h2>
      <p>가장 자주 사용하는 패키지 관리 명령어를 비교합니다.</p>

      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>설치 (Install)</span>
          <div style="margin-top: 8px; font-family: 'JetBrains Mono', monospace; font-size: 0.85em;">
            <div style="color: #ff6b6b; margin-bottom: 4px;">dnf install [pkg]</div>
            <div style="color: #4ecdc4;">apt install [pkg]</div>
          </div>
        </div>
        <div class="shortcut-card">
          <span>업데이트 (Update)</span>
          <div style="margin-top: 8px; font-family: 'JetBrains Mono', monospace; font-size: 0.85em;">
            <div style="color: #ff6b6b; margin-bottom: 4px;">dnf update</div>
            <div style="color: #4ecdc4;">apt upgrade</div>
          </div>
        </div>
        <div class="shortcut-card">
          <span>삭제 (Remove)</span>
          <div style="margin-top: 8px; font-family: 'JetBrains Mono', monospace; font-size: 0.85em;">
            <div style="color: #ff6b6b; margin-bottom: 4px;">dnf remove [pkg]</div>
            <div style="color: #4ecdc4;">apt remove [pkg]</div>
          </div>
        </div>
        <div class="shortcut-card">
          <span>검색 (Search)</span>
          <div style="margin-top: 8px; font-family: 'JetBrains Mono', monospace; font-size: 0.85em;">
            <div style="color: #ff6b6b; margin-bottom: 4px;">dnf search [pkg]</div>
            <div style="color: #4ecdc4;">apt search [pkg]</div>
          </div>
        </div>
      </div>

      <h2>3. 시스템 설정 경로 차이</h2>
      <p>초기 서버 세팅 시 가장 많이 건드리는 파일 경로입니다.</p>

      <h3>네트워크 설정 (Network Config)</h3>
      <ul style="list-style: disc; margin-left: 20px; line-height: 1.8;">
        <li>
          <strong>Red Hat 계열:</strong> <code>/etc/sysconfig/network-scripts/</code> 디렉토리에 <code>ifcfg-eth0</code> 형태로
          존재.<br>
          <span style="font-size: 0.9em; opacity: 0.7;">(최근 Rocky 9 등에서는 NetworkManager 사용 권장)</span>
        </li>
        <li>
          <strong>Debian 계열:</strong> <code>/etc/network/interfaces</code> 파일 또는 <code>/etc/netplan/*.yaml</code>
          (Ubuntu) 사용.
        </li>
      </ul>

      <h3 style="margin-top: 20px;">서비스 관리 (Service)</h3>
      <p>과거에는 <code>service</code> vs <code>systemctl</code>의 차이가 있었으나, 현재는 대부분 <strong>Systemd</strong>로 통일되었습니다.</p>
      <pre><code class="language-bash"># 서비스 시작 (공통)
sudo systemctl start sshd

# 부팅 시 자동 실행 설정 (공통)
sudo systemctl enable sshd</code></pre>

      <div class="note-box">
        <i data-lucide="check-circle"></i>
        <div>
          <strong>FPGA 엔지니어라면?</strong><br>
          EDA 툴(Synopsys, Cadence, Xilinx)은 공식적으로 <strong>RHEL/CentOS</strong>를 지원합니다. 따라서 FPGA/ASIC 리눅스 서버를 구축할 때는 고민하지
          말고 Rocky Linux (RHEL 호환)를 선택하세요.
        </div>
      </div>
    </section>

    <!-- ROCKY SETUP SECTION -->
    <section id="linux-setup" class="content-section">
      <h1>Rocky Linux 9 for EDA Server</h1>
      <p>단순한 OS 설치를 넘어, 수천만 원짜리 EDA 툴이 돌아가는 <strong>엔터프라이즈급 서버 구축 노하우</strong>를 공유합니다.</p>

      <h2>1. 파티션 및 파일시스템 전략</h2>
      <p>OS 재설치 시에도 데이터와 툴을 보호하기 위해 물리적/논리적 파티션 분리는 필수입니다.</p>
      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>/ (Root)</span>
          <span style="font-size: 0.9em; opacity: 0.8;">OS 시스템 영역. 50GB~100GB 권장.</span>
        </div>
        <div class="shortcut-card">
          <span>/tools</span>
          <span style="font-size: 0.9em; opacity: 0.8;">EDA 툴 설치 경로. OS와 완전히 분리 필수.</span>
        </div>
        <div class="shortcut-card">
          <span>/home</span>
          <span style="font-size: 0.9em; opacity: 0.8;">사용자 데이터. 백업 1순위.</span>
        </div>
        <div class="shortcut-card">
          <span>SWAP</span>
          <span style="font-size: 0.9em; opacity: 0.8;">PHY 합성 시 RAM 부족 대비. RAM 용량의 0.5배 이상.</span>
        </div>
      </div>

      <h2>2. 필수 의존성 패키지 (Ghost Libraries)</h2>
      <p>최신 OS(Rocky 9)에 이전 세대 EDA 툴을 설치할 때 발생하는 라이브러리 에러 해결책입니다.</p>
      <pre><code class="language-bash"># 1. EPEL 저장소 활성화
sudo dnf install -y epel-release

# 2. 필수 시스템 라이브러리 & 개발 툴
sudo dnf groupinstall -y "Development Tools"
sudo dnf install -y redhat-lsb-core git wget htop

# 3. EDA 툴 구동을 위한 Legacy 라이브러리 (Crucial!)
# libnsl: FlexLM 라이센스 데몬이 주로 사용
# libX*: Vivado/Questasim GUI 구동용
sudo dnf install -y libnsl libX11 libXext libXft libXtst \
    ncurses-compat-libs \
    libstdc++.i686 glibc.i686</code></pre>

      <div class="note-box">
        <i data-lucide="alert-triangle"></i>
        <div>
          <strong>주의: SELinux 및 방화벽</strong><br>
          FlexLM 라이센스 서버 통신 문제 해결을 위해, 내부망일 경우 SELinux는 <code>Permissive</code>로, 방화벽은 특정 포트(27000~27009)를 개방하거나 비활성화해야
          할 수 있습니다.
        </div>
      </div>

      <h2>3. EDA 툴 설치 표준 절차</h2>
      <p>EDA 툴은 설치 위치와 권한 설정이 매우 중요합니다. 무턱대고 <code>root</code>로 설치하면 나중에 관리가 어려워집니다.</p>

      <h3>1단계: 설치 디렉토리 준비 (Root 권한 필요)</h3>
      <p>통상적으로 <code>/tools</code> 또는 <code>/opt</code>를 사용합니다. 폴더를 만들고 <strong>소유권을 관리자 계정(또는 본인)으로 변경</strong>해야 합니다.
      </p>
      <pre><code class="language-bash"># 1. 디렉토리 생성 (Root)
sudo mkdir -p /tools/Xilinx

# 2. 소유권 변경 (중요!)
# root가 아닌, 실제 설치를 진행할 사용자($USER)에게 권한을 줍니다.
sudo chown -R $USER:$USER /tools/Xilinx</code></pre>

      <h3>2단계: 설치 프로그램 실행 (GUI)</h3>
      <p>이제 <code>sudo</code> 없이 설치 프로그램을 실행합니다. 그래야 생성되는 파일들이 온전히 내 계정 소유가 됩니다.</p>
      <pre><code class="language-bash"># 설치 프로그램 실행 (sudo 사용 금지!)
./xsetup</code></pre>

      <h3>3단계: 설치 후 환경설정 고려사항</h3>
      <p>설치가 완료되면 벤더가 제공하는 설정 파일(예: <code>settings64.sh</code>) 위치를 파악해둡니다. 이 내용을 바탕으로 다음 섹션의 <strong>나만의 설정
          스크립트</strong>를 만듭니다.</p>

      <div class="note-box">
        <i data-lucide="users"></i>
        <div>
          <strong>Q: 특정 사용자로 설치하면 다른 사람은 못 쓰나요?</strong><br>
          아닙니다! 리눅스 디렉토리는 기본적으로 <strong>755 (drwxr-xr-x)</strong> 권한을 가집니다. 이는 소유자만 수정(Write)할 수 있고, 다른 사용자들은 <strong>읽기
            및 실행(Read/Execute)</strong>이 가능하다는 뜻입니다. 따라서 설치는 특정 관리자 계정으로 진행하고, 사용은 모든 팀원이 문제없이 할 수 있습니다.
        </div>
      </div>

      <h2>4. 버전별 환경 설정 관리 (Shell Script 활용)</h2>
      <p>Environment Modules와 같은 도구는 설정이 복잡할 수 있습니다. 대신 <strong>버전별 설정 스크립트</strong>를 만들어 필요할 때만 <code>source</code> 하는
        방식이 훨씬 직관적입니다.</p>

      <h3>1. 설정 스크립트 작성 (예: ~/env_vivado_2023.sh)</h3>
      <pre><code class="language-bash">#!/bin/bash
# 2023 버전 경로를 PATH의 맨 앞에 추가(Prepend)
export XILINX_VIVADO=/tools/Xilinx/Vivado/2023.2
export PATH=$XILINX_VIVADO/bin:$PATH

echo "Vivado 2023.2 환경이 로드되었습니다."</code></pre>

      <h3>2. 환경변수 적용 (Source)</h3>
      <p>스크립트를 실행(<code>./Example.sh</code>)하면 자식 쉘에서만 적용되고 사라집니다. 반드시 <strong>source</strong> 명령어로 현재 쉘에 적용해야 합니다.</p>
      <pre><code class="language-bash">source ~/env_vivado_2023.sh</code></pre>

      <div class="note-box">
        <i data-lucide="help-circle"></i>
        <div>
          <strong>자주 묻는 질문: PATH가 계속 쌓이지 않나요?</strong><br>
          맞습니다. 여러 버전을 계속 source 하면 PATH 변수가 길어집니다.
          하지만 위 스크립트는 경로를 <strong>맨 앞($PATH 왼쪽)</strong>에 붙이기 때문에, 시스템은 항상 <strong>가장 최근에 로드한 버전의 명령어</strong>를 우선적으로
          찾습니다.
          따라서 기능상 충돌 없이 정상 작동합니다.
        </div>
      </div>

      <h3>3. 편의성 팁 (Alias 설정)</h3>
      <p>매번 긴 경로를 입력하기 귀찮다면 <code>.bashrc</code>에 단축어를 등록하세요.</p>
      <pre><code class="language-bash"># ~/.bashrc 파일 하단에 추가
alias v2023='source ~/env_vivado_2023.sh'
alias v2024='source ~/env_vivado_2024.sh'</code></pre>

      <h2>5. 다중 사용자 권한 관리 (협업의 핵심)</h2>
      <p>여러 엔지니어가 하나의 프로젝트 폴더를 공유할 때, <strong>"동료가 만든 파일을 수정할 수 없는 문제(Permission Denied)"</strong>가 반드시 발생합니다. 매번
        <code>chmod 777</code>을 하는 것은 보안상 최악입니다.
      </p>
      <p>관리자가 개입하지 않아도 팀원끼리 자유롭게 파일을 수정할 수 있는 <strong>3단계 표준 절차</strong>를 예시와 함께 설명합니다.</p>

      <h3>1. 문제 상황 (Scenario)</h3>
      <p>엔지니어 A와 B가 같은 팀이지만, A가 만든 파일을 B가 수정하려고 하면 <strong>"권한 없음"</strong> 에러가 뜹니다. 이는 리눅스의 기본 설정이 "본인만 수정 가능"하기 때문입니다.
      </p>

      <h3>2. 해결책: SetGID와 Umask 콤보</h3>
      <div class="shortcut-grid">
        <div class="shortcut-card" style="flex-direction: column; align-items: flex-start; white-space: normal;">
          <strong style="margin-bottom: 8px; color: var(--accent-color);">1. SetGID (g+s) 설정</strong>
          <span style="font-size: 0.9em; opacity: 0.8; line-height: 1.5;">"이 폴더 안에 생기는 모든 파일은 <strong>자동으로 팀 그룹
              소유</strong>가 된다."<br>(작성자의 개인 그룹이 아님)</span>
        </div>
        <div class="shortcut-card" style="flex-direction: column; align-items: flex-start; white-space: normal;">
          <strong style="margin-bottom: 8px; color: var(--accent-color);">2. Umask 002 설정</strong>
          <span style="font-size: 0.9em; opacity: 0.8; line-height: 1.5;">"파일을 만들 때 <strong>같은 팀원에게도 수정(쓰기) 권한</strong>을
            준다."<br>(기본값은 읽기만 가능)</span>
        </div>
      </div>

      <h3 style="margin-top: 20px;">3. 따라해보기 (Best Practice)</h3>
      <pre><code class="language-bash"># [관리자] 1. 프로젝트 폴더 생성 및 그룹 지정
sudo mkdir /data/project_X
sudo chown root:eda_users /data/project_X

# [관리자] 2. 핵심! SetGID 비트 설정
# g+s를 하면 그룹 권한 자리에 's'가 생깁니다 (drwxr-sr-x)
sudo chmod g+s /data/project_X

# [사용자] 3. Umask 설정을 .bashrc에 추가
# "내가 만드는 파일은 팀원도 수정할 수 있게(rw-rw-r--) 해주세요"
echo "umask 002" >> ~/.bashrc</code></pre>

      <div class="note-box">
        <i data-lucide="check-circle"></i>
        <div>
          <strong>결과:</strong><br>
          이제 엔지니어 A가 파일을 생성해도, 소유 그룹은 자동으로 <code>eda_users</code>가 되고 권한은 <code>rw-</code>(쓰기 가능)로 설정됩니다. 엔지니어 B는 자유롭게
          수정할 수 있습니다.
        </div>
      </div>
    </section>

    <!-- SERVER OPS SECTION -->
    <section id="server-ops" class="content-section">
      <h1>Server & User Management</h1>
      <p>여러 엔지니어가 사용하는 시뮬레이션 서버를 관리하기 위한 필수 명령어입니다.</p>

      <h2>1. 사용자 추가 및 그룹 관리</h2>
      <pre><code class="language-bash"># EDA 그룹 생성
sudo groupadd eda_users

# 사용자 생성 (홈 디렉토리 포함, bash 쉘 사용, 그룹 지정)
sudo useradd -m -g eda_users -s /bin/bash engineer01

# 비밀번호 설정
sudo passwd engineer01</code></pre>

      <h2>2. 데이터 및 툴 디렉토리 권한</h2>
      <p>EDA 툴은 보통 <code>/tools</code> 또는 <code>/opt</code>에 설치하며, 공용 라이브러리는 읽기 전용으로 관리합니다.</p>
      <pre><code class="language-bash"># 디렉토리 생성
sudo mkdir -p /tools/xilinx /tools/mentor

# 소유권 변경 (관리자: root, 그룹: eda_users)
sudo chown -R root:eda_users /tools

# 권한 설정 (소유자: RWX, 그룹: RX, 기타: RX)
sudo chmod -R 755 /tools</code></pre>
      <h2>3. 파일 관리 및 압축 (Archiving)</h2>
      <p>프로젝트 백업 및 대용량 시뮬레이션 데이터 이동 시 필수적인 명령어입니다.</p>

      <h3>파일 복사 및 이동</h3>
      <pre><code class="language-bash"># 디렉토리 통째로 복사 (-r: recursive, -p: 권한 보존, -v: 상세 출력)
cp -rpv project_v1 project_v1_backup

# 파일 이동 및 이름 변경
mv old_name.v new_name.v
mv *.v ../backup/</code></pre>

      <h3>압축 및 해제 (tar)</h3>
      <p>Linux에서는 주로 <code>tar.gz</code> 형식을 사용합니다. 옵션 순서(czvf)를 외워두면 편합니다.</p>
      <div class="note-box">
        <i data-lucide="package"></i>
        <div>
          <strong>핵심 옵션:</strong>
          <ul style="list-style: disc; margin-left: 20px; margin-top: 5px;">
            <li><strong>c</strong>: Create (압축 생성)</li>
            <li><strong>x</strong>: Extract (압축 해제)</li>
            <li><strong>z</strong>: gzip 압축 사용</li>
            <li><strong>v</strong>: Verbose (과정 출력)</li>
            <li><strong>f</strong>: File (파일명 지정, 항상 마지막에 위치)</li>
          </ul>
        </div>
      </div>

      <pre><code class="language-bash"># 프로젝트 압축하기 (현재 디렉토리의 projectA 폴더를 archive.tar.gz로)
tar -czvf archive.tar.gz ./projectA

# 압축 해제하기
tar -xzvf archive.tar.gz

# 특정 디렉토리에 풀기 (-C 옵션)
tar -xzvf archive.tar.gz -C /data/restore/</code></pre>
    </section>

    <!-- FPGA WORKFLOW SECTION (Questasim & Make) -->
    <section id="fpga-workflow" class="content-section">
      <h1>FPGA Simulation Workflow</h1>
      <p>FPGA 개발의 꽃은 시뮬레이션입니다. Questasim과 Vivado를 리눅스 터미널(Makefile)에서 제어하는 방법을 마스터하세요.</p>

      <h2>1. Questasim Makefile 완벽 분석</h2>
      <p>단순히 복사해서 쓰는 것이 아니라, 각 명령어의 의미를 이해해야 에러를 잡을 수 있습니다.</p>

      <div class="note-box">
        <i data-lucide="book-open"></i>
        <div>
          <strong>핵심 명령어 설명:</strong>
          <ul style="list-style: disc; margin-left: 20px; margin-top: 10px;">
            <li><code>vlib work</code>: 컴파일된 디자인 유닛들이 저장될 물리적인 디렉토리를 생성합니다.</li>
            <li><code>vmap work work</code>: 논리적인 라이브러리 이름(work)을 물리적 디렉토리에 매핑합니다.</li>
            <li><code>vlog</code>: Verilog/SystemVerilog 컴파일러. <code>+incdir+</code> 옵션으로 헤더 파일 경로를 지정하는 것이 필수입니다.</li>
            <li><code>vopt</code>: <strong>Visualizer 최적화</strong>. <code>-o opt -debug +designfile</code> 옵션으로 디버그 정보가
              포함된 최적화 객체를 생성합니다.</li>
            <li><code>vsim</code>: <code>-qwavedb=+signal</code> 옵션을 사용하여 Visualizer용 고속 시뮬레이션 DB를 생성합니다.</li>
          </ul>
        </div>
      </div>

      <pre><code class="language-makefile"># Makefile for Questasim (Visualizer Flow)
RTL_DIR = ../src
TB_DIR  = ../tb
WORK    = work
RTL_LIST = ../sim/run.f
TOP     = tb_top
OPT     = opt

# Visualizer GUI Live Simulation (with QWaveDB)
gui: clean compiled optimize
	vsim $(OPT) -visualizer -qwavedb=+signal -do "run 10 us"

# Batch / Post simulation mode
sim: clean compiled optimize
	vsim -batch $(OPT) -qwavedb=+signal -do "run -all; quit"

optimize:
	# vopt: Optimize & Debug options (+designfile for Visualizer)
	vopt $(WORK).$(TOP) -o $(OPT) -debug +designfile -L $(WORK)

compiled:
	vlib $(WORK)
	vmap work $(WORK)
	vlog -work $(WORK) +incdir+$(RTL_DIR) -f $(RTL_LIST)
	vlog -work $(WORK) +incdir+$(TB_DIR) $(TB_DIR)/$(TOP).v

# load wave database for visualizer
wave: 
	vis design.bin qwave.db &

clean:
	rm -rf $(WORK) transcript vsim.wlf qwave.db visualizer.log</code></pre>

      <div class="note-box">
        <i data-lucide="file-text"></i>
        <div>
          <strong>run.f 파일 예시:</strong><br />
          와일드카드(*.v)는 파일 로드 순서를 보장하지 않습니다. 상위 모듈이 하위 모듈보다 먼저 오지 않도록, 파일 리스트에서 의존성 순서대로 명시하는 것이 정석입니다.
          <pre><code class="language-plaintext" style="margin-top: 10px; background: #000; padding: 10px;">// 주석 가능
../src/defines.v
../src/alu.v
../src/cpu_top.v
</code></pre>
        </div>
      </div>

      <h2>2. Vivado 배포/합성 자동화 (Batch Mode)</h2>
      <p>Vivado에서도 파일 리스트(sources.f)를 Tcl로 파싱하여 관리하는 것이 유지보수에 좋습니다.</p>
      <pre><code class="language-makefile"># Makefile for Vivado
bitstream: 
	vivado -mode batch -source run_synth.tcl</code></pre>

      <h3>예시: run_synth.tcl (파일 리스트 읽기)</h3>
      <pre><code class="language-tcl"># run_synth.tcl
create_project -in_memory -part xc7a35ticsg324-1L

# 파일 리스트 읽기 함수
set fp [open "sources.f" r]
set file_data [read $fp]
close $fp

# 라인별로 읽어서 read_verilog 실행
foreach line [split $file_data "\n"] {
    # 빈 줄이나 주석(#) 제외
    if {[string length $line] > 0 && ![string match "#*" $line]} {
        read_verilog $line
    }
}

read_xdc ../const/pins.xdc

synth_design -top top_module -part xc7a35ticsg324-1L
opt_design
place_design
route_design
write_bitstream -force ./build_output/final.bit</code></pre>
    </section>

    <!-- VIM MASTERY SECTION -->
    <section id="vim-mastery" class="content-section">
      <h1>VIM Mastery: Pro Level</h1>
      <p>기본 이동을 넘어서, 코딩 속도를 2배로 올려줄 고급 기능들입니다.</p>

      <h2>1. 기본 이동 및 편집 (Essentials)</h2>
      <p>마우스에 손이 가는 순간 패배입니다. 키보드 홈 포지션에서 모든 것을 해결하세요.</p>

      <h3>커서 이동 (Movement)</h3>
      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>기본 이동</span>
          <span class="kbd-group"><span class="key">h</span><span class="key">j</span><span class="key">k</span><span
              class="key">l</span> (좌/하/상/우)</span>
        </div>
        <div class="shortcut-card">
          <span>단어 단위 이동 (점프)</span>
          <span class="kbd-group"><span class="key">w</span> (다음), <span class="key">b</span> (이전)</span>
        </div>
      </div>

      <h3 style="margin-top:20px;">선택과 편집 (Visual & Edit)</h3>
      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>텍스트 선택 (Visual Mode)</span>
          <span class="kbd-group"><span class="key">v</span> + 이동 &rarr; 선택</span>
        </div>
        <div class="shortcut-card">
          <span>복사 / 붙여넣기</span>
          <span class="kbd-group"><span class="key">y</span> (Yank), <span class="key">p</span> (Paste)</span>
        </div>
        <div class="shortcut-card">
          <span>잘라내기 (삭제)</span>
          <span class="kbd-group"><span class="key">d</span> (Delete/Cut)</span>
        </div>
        <div class="shortcut-card">
          <span>되돌리기 (Undo/Redo)</span>
          <span class="kbd-group"><span class="key">u</span> / <span class="key">Ctrl</span>+<span
              class="key">r</span></span>
        </div>
      </div>

      <h2>2. 파일 조작 및 쉘 전환 (File Ops & Shell)</h2>
      <p>가장 기초적인 파일 열기, 저장, 종료 방법과 작업 중 잠시 쉘로 나가는 방법입니다.</p>

      <h3>파일 열기 및 저장/종료</h3>
      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>파일 열기</span>
          <span class="kbd-group"><span class="key">vim</span><span>파일명</span></span>
        </div>
        <div class="shortcut-card">
          <span>저장하기</span>
          <span class="kbd-group"><span class="key">:</span><span>w</span></span>
        </div>
        <div class="shortcut-card">
          <span>저장하고 종료</span>
          <span class="kbd-group"><span class="key">:</span><span>wq</span></span>
        </div>
        <div class="shortcut-card">
          <span>강제 종료 (저장X)</span>
          <span class="kbd-group"><span class="key">:</span><span>q!</span></span>
        </div>
      </div>

      <h3>잠시 쉘로 나가기 (Suspend/Foreground)</h3>
      <p>편집기를 끄지 않고 터미널 명령어를 써야 할 때(예: git status, 파일 목록 확인) 유용합니다.</p>
      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>작업 일시 중단 (Suspend)</span>
          <span class="kbd-group"><span class="key">Ctrl</span>+<span class="key">z</span></span>
        </div>
        <div class="shortcut-card">
          <span>편집기 복귀 (Foreground)</span>
          <span class="kbd-group"><span class="key">fg</span></span>
        </div>
      </div>

      <h2>3. 비주얼 블록 모드 (Visual Block) - Verilog 필수!</h2>
      <p>Verilog 포트 리스트나 인스턴스를 연결할 때, <strong>세로로 드래그해서 한 번에 편집</strong>하는 기능입니다. 이것만 알면 작업 속도가 3배 빨라집니다.</p>

      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>블록 지정 시작</span>
          <span class="kbd-group"><span class="key">Ctrl</span>+<span class="key">v</span></span>
        </div>
        <div class="shortcut-card" style="flex-direction:column; align-items:flex-start; white-space:normal;">
          <span style="font-weight:bold; margin-bottom:5px;">블록 내 일괄 입력 (Multi Insert)</span>
          <span class="kbd-group" style="font-size:0.9em"><span class="key">Shift</span>+<span class="key">i</span>
            &rarr; 입력 &rarr; <span class="key">ESC</span></span>
        </div>
        <div class="shortcut-card">
          <span>블록 삭제/복사</span>
          <span class="kbd-group"><span class="key">x</span> (삭제), <span class="key">y</span> (복사)</span>
        </div>
        <div class="shortcut-card">
          <span>문자열 덮어쓰기</span>
          <span class="kbd-group"><span class="key">r</span> + <span class="key">문자</span></span>
        </div>
      </div>

      <h2>4. 전광석화 코드 탐색 (Navigation)</h2>
      <p>긴 코드에서 길을 잃지 않으려면 커서 이동 마스터가 되어야 합니다.</p>
      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>현재 단어 검색 (Highlight)</span>
          <span class="kbd-group"><span class="key">*</span> (다음), <span class="key">#</span> (이전)</span>
        </div>
        <div class="shortcut-card">
          <span>괄호 짝 찾기 ( { &lt;-&gt; } )</span>
          <span class="kbd-group"><span class="key">%</span></span>
        </div>
        <div class="shortcut-card">
          <span>파일 상/하단 이동</span>
          <span class="kbd-group"><span class="key">gg</span> (맨위), <span class="key">G</span> (맨아래)</span>
        </div>
        <div class="shortcut-card">
          <span>이전 커서 위치 복귀</span>
          <span class="kbd-group"><span class="key">Ctrl</span>+<span class="key">o</span></span>
        </div>
      </div>

      <h2>5. 다중 창 활용 (Window Splits)</h2>
      <p>Testbench와 RTL 코드를 동시에 띄워놓고 비교할 때 필수입니다.</p>
      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>세로 분할 (Vertical Split)</span>
          <span class="kbd-group"><span class="key">:</span><span>vsp 파일명</span></span>
        </div>
        <div class="shortcut-card">
          <span>가로 분할 (Horizontal Split)</span>
          <span class="kbd-group"><span class="key">:</span><span>sp 파일명</span></span>
        </div>
        <div class="shortcut-card">
          <span>창 간 이동</span>
          <span class="kbd-group"><span class="key">Ctrl</span>+<span class="key">w</span>, <span
              class="key">w</span></span>
        </div>
        <div class="shortcut-card">
          <span>현재 창 닫기</span>
          <span class="kbd-group"><span class="key">:</span><span>q</span></span>
        </div>
      </div>

      <h2>6. 검색 및 일괄 치환 (Search & Replace)</h2>
      <p>변수명을 한 번에 바꿀 때 유용합니다. Verilog 리팩토링의 핵심입니다.</p>
      <pre><code class="language-bash"># 기본 검색 (Normal Mode)
/clk_en      # 아래로 'clk_en' 검색
?reset_n     # 위로 'reset_n' 검색
n / N        # 다음 / 이전 찾기

# 단어 바로 찾기
*            # 커서가 위치한 단어를 즉시 검색

# 치환 (Substitute)
# 문법: :[범위]s/찾을단어/바꿀단어/[플래그]

# 1. 파일 전체 치환 ('%'는 전체 파일을 의미)
:%s/wire/reg/g       # 파일의 첫 줄부터 끝 줄까지 모든 'wire' 변경

# 2. 현재 줄만 치환 ('%' 생략 시 커서가 있는 줄만 대상)
:s/wire/reg/g        # 현재 커서가 있는 줄의 'wire'만 변경

# 3. 특정 범위 지정
:10,20s/wire/reg/g   # 10번 줄부터 20번 줄까지만 변경

# Tip: 'g' (global) 플래그를 빼면 각 줄의 첫 번째 일치 항목만 바뀝니다.
# :%s/old/new        # (각 줄의 첫 번째 'old'만 'new'로 변경)</code></pre>

      <h2>7. 매크로 (Macros): 반복 작업 자동화</h2>
      <p>규칙적인 노가다성 코드 수정(예: 100개의 포트 연결)을 자동화합니다.</p>
      <ol style="margin-left: 20px; line-height: 2;">
        <li><strong>녹화 시작:</strong> Normal Mode에서 <span class="key">q</span> 누르고 레지스터 키(예: <span class="key">a</span>)
          누름 &rarr; 상태바에 <code>recording @a</code> 표시됨.</li>
        <li><strong>작업 수행:</strong> 반복할 작업을 1회 수행 (예: 줄 끝에 콤마 찍고 아래로 이동).</li>
        <li><strong>녹화 종료:</strong> <span class="key">q</span> 다시 누름.</li>
        <li><strong>실행:</strong> <span class="key">@</span><span class="key">a</span> (1회 실행) 또는 <span
            class="key">100</span><span class="key">@</span><span class="key">a</span> (100회 반복).</li>
      </ol>

      <h2>8. .vimrc 설정 (엔지니어 필수)</h2>
      <p>홈 디렉토리의 <code>~/.vimrc</code> 파일에 아래 내용을 추가하여 가독성을 높이세요.</p>
      <pre><code class="language-plaintext">" 문법 강조
syntax on

" 줄 번호 표시
set number

" 자동 들여쓰기 (Verilog 코딩 시 필수)
set autoindent
set cindent

" 탭 대신 스페이스 4칸 사용 (팀 코딩 컨벤션)
set expandtab
set tabstop=4
set shiftwidth=4

" 검색 시 대소문자 무시하되, 대문자 섞이면 구분
set ignorecase
set smartcase

" 괄호 짝 찾기 하이라이트
set showmatch</code></pre>
    </section>

  </main>

  <div class="status-bar">
    <span>MODE: NORMAL</span>
    <span>pos: 1,1</span>
    <span>file: linux_lect_v1.0</span>
  </div>

  <script type="module" src="/src/main.js"></script>
</body>

</html>