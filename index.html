<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FPGA Linux & VIM Master Class</title>
  <link rel="stylesheet" href="./style.css" />
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=JetBrains+Mono:wght@400;700&display=swap"
    rel="stylesheet">
  <!-- Highlight.js Theme -->
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark-dimmed.min.css">
</head>

<body>
  <!-- Mobile Menu Toggle -->
  <button id="menu-toggle" aria-label="Toggle Menu">
    <i data-lucide="menu"></i>
  </button>

  <aside>
    <div class="brand">
      <i data-lucide="cpu"></i>
      <span>FPGA.env</span>
    </div>
    <nav>
      <ul>
        <li class="nav-item active" data-target="home">
          <i data-lucide="home"></i> Home
        </li>
        <li class="nav-item" data-target="distro-compare">
          <i data-lucide="scale"></i> Distro Comparison
        </li>
        <li class="nav-item" data-target="linux-setup">
          <i data-lucide="terminal-square"></i> Rocky 9 Setup
        </li>
        <li class="nav-item" data-target="server-ops">
          <i data-lucide="server"></i> Server Ops
        </li>
        <li class="nav-item" data-target="vim-mastery">
          <i data-lucide="pencil-ruler"></i> VIM Mastery
        </li>
        <li class="nav-item" data-target="fpga-workflow">
          <i data-lucide="workflow"></i> FPGA Simulation Workflow
        </li>
      </ul>
    </nav>
  </aside>

  <main>
    <!-- HOME SECTION -->
    <section id="home" class="content-section active">
      <h1>FPGA 엔지니어를 위한 Linux & VIM</h1>
      <p>환영합니다. 이 가이드는 FPGA 개발을 위한 최적의 리눅스 환경 구축과 VIM 에디터 활용법을 다룹니다.</p>

      <div class="note-box">
        <i data-lucide="info"></i>
        <div>
          <strong>왜 리눅스인가요?</strong><br />
          EDA 툴(Vivado, Questasim, Quartus)은 리눅스 환경에서 최고의 안정성과 성능을 발휘합니다. 특히 대규모 시뮬레이션과 서버 기반의 워크플로우는 리눅스 지식을 필수로 요구합니다.
        </div>
      </div>

      <h2>커리큘럼 개요</h2>
      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>Rocky Linux 9 환경 구축</span>
          <i data-lucide="check-circle" style="color: var(--accent-color)"></i>
        </div>
        <div class="shortcut-card">
          <span>사용자 및 데이터 권한 관리</span>
          <i data-lucide="check-circle" style="color: var(--accent-color)"></i>
        </div>
        <div class="shortcut-card">
          <span>VIM Mastery (Pro Level)</span>
          <i data-lucide="check-circle" style="color: var(--accent-color)"></i>
        </div>
        <div class="shortcut-card">
          <span>FPGA Simulation Workflow</span>
          <i data-lucide="check-circle" style="color: var(--accent-color)"></i>
        </div>
      </div>
    </section>

    <!-- DISTRO COMPARISON SECTION -->
    <section id="distro-compare" class="content-section">
      <h1>Red Hat vs Debian</h1>
      <p>리눅스 생태계의 양대 산맥인 Red Hat 계열과 Debian 계열의 차이를 명확히 이해하고, 목적에 맞는 OS를 선택하는 것이 중요합니다.</p>

      <h2>1. 주요 계열 비교 (RHEL vs Debian)</h2>
      <div class="note-box">
        <i data-lucide="info"></i>
        <div>
          <strong>핵심 요약:</strong> 수천 개의 배포판이 있지만, 엔터프라이즈 환경은 <strong>RHEL(Red Hat)</strong>, 사용자 및 개발자 환경은
          <strong>Debian/Ubuntu</strong>가 주도합니다.
        </div>
      </div>

      <div style="margin-top: 20px; overflow-x: auto;">
        <table style="width: 100%; border-collapse: collapse; text-align: left; border: 1px solid var(--border-color);">
          <thead>
            <tr style="background-color: var(--secondary-bg); border-bottom: 2px solid var(--border-color);">
              <th style="padding: 12px; font-weight: 600;">구분</th>
              <th style="padding: 12px; font-weight: 600; color: #ff6b6b;">Red Hat (RHEL) 계열</th>
              <th style="padding: 12px; font-weight: 600; color: #4ecdc4;">Debian 계열</th>
            </tr>
          </thead>
          <tbody>
            <tr style="border-bottom: 1px solid var(--border-color);">
              <td style="padding: 12px; font-weight: 600;">주요 배포판</td>
              <td style="padding: 12px;">RHEL, CentOS, Rocky, Fedora</td>
              <td style="padding: 12px;">Ubuntu, Debian, Kali, Mint</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border-color);">
              <td style="padding: 12px; font-weight: 600;">패키지 포맷</td>
              <td style="padding: 12px;">.rpm</td>
              <td style="padding: 12px;">.deb</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border-color);">
              <td style="padding: 12px; font-weight: 600;">패키지 관리자</td>
              <td style="padding: 12px;">yum, dnf</td>
              <td style="padding: 12px;">apt, apt-get</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border-color);">
              <td style="padding: 12px; font-weight: 600;">특징 & 철학</td>
              <td style="padding: 12px;">보수적 업데이트, 강력한 보안/안정성,<br>기업용 서버 표준</td>
              <td style="padding: 12px;">빠른 업데이트, 방대한 패키지,<br>개발자/데스크탑 친화적</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h2>2. 필수 명령어 차이점</h2>
      <p>가장 자주 사용하는 패키지 관리 명령어를 비교합니다.</p>

      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>설치 (Install)</span>
          <div style="margin-top: 8px; font-family: 'JetBrains Mono', monospace; font-size: 0.85em;">
            <div style="color: #ff6b6b; margin-bottom: 4px;">dnf install [pkg]</div>
            <div style="color: #4ecdc4;">apt install [pkg]</div>
          </div>
        </div>
        <div class="shortcut-card">
          <span>업데이트 (Update)</span>
          <div style="margin-top: 8px; font-family: 'JetBrains Mono', monospace; font-size: 0.85em;">
            <div style="color: #ff6b6b; margin-bottom: 4px;">dnf update</div>
            <div style="color: #4ecdc4;">apt upgrade</div>
          </div>
        </div>
        <div class="shortcut-card">
          <span>삭제 (Remove)</span>
          <div style="margin-top: 8px; font-family: 'JetBrains Mono', monospace; font-size: 0.85em;">
            <div style="color: #ff6b6b; margin-bottom: 4px;">dnf remove [pkg]</div>
            <div style="color: #4ecdc4;">apt remove [pkg]</div>
          </div>
        </div>
        <div class="shortcut-card">
          <span>검색 (Search)</span>
          <div style="margin-top: 8px; font-family: 'JetBrains Mono', monospace; font-size: 0.85em;">
            <div style="color: #ff6b6b; margin-bottom: 4px;">dnf search [pkg]</div>
            <div style="color: #4ecdc4;">apt search [pkg]</div>
          </div>
        </div>
      </div>

      <h2>3. 시스템 설정 경로 차이</h2>
      <p>초기 서버 세팅 시 가장 많이 건드리는 파일 경로입니다.</p>

      <h3>네트워크 설정 (Network Config)</h3>
      <ul style="list-style: disc; margin-left: 20px; line-height: 1.8;">
        <li>
          <strong>Red Hat 계열:</strong> <code>/etc/sysconfig/network-scripts/</code> 디렉토리에 <code>ifcfg-eth0</code> 형태로
          존재.<br>
          <span style="font-size: 0.9em; opacity: 0.7;">(최근 Rocky 9 등에서는 NetworkManager 사용 권장)</span>
        </li>
        <li>
          <strong>Debian 계열:</strong> <code>/etc/network/interfaces</code> 파일 또는 <code>/etc/netplan/*.yaml</code>
          (Ubuntu) 사용.
        </li>
      </ul>

      <h3 style="margin-top: 20px;">서비스 관리 (Service)</h3>
      <p>과거에는 <code>service</code> vs <code>systemctl</code>의 차이가 있었으나, 현재는 대부분 <strong>Systemd</strong>로 통일되었습니다.</p>
      <pre><code class="language-bash"># 서비스 시작 (공통)
sudo systemctl start sshd

# 부팅 시 자동 실행 설정 (공통)
sudo systemctl enable sshd</code></pre>

      <div class="note-box">
        <i data-lucide="check-circle"></i>
        <div>
          <strong>FPGA 엔지니어라면?</strong><br>
          EDA 툴(Synopsys, Cadence, Xilinx)은 공식적으로 <strong>RHEL/CentOS</strong>를 지원합니다. 따라서 FPGA/ASIC 리눅스 서버를 구축할 때는 고민하지
          말고 Rocky Linux (RHEL 호환)를 선택하세요.
        </div>
      </div>
    </section>

    <!-- ROCKY SETUP SECTION -->
    <section id="linux-setup" class="content-section">
      <h1>Rocky Linux 9 for EDA Server</h1>
      <p>단순한 OS 설치를 넘어, 수천만 원짜리 EDA 툴이 돌아가는 <strong>엔터프라이즈급 서버 구축 노하우</strong>를 공유합니다.</p>

      <h2>1. 파티션 및 파일시스템 전략</h2>
      <p>OS 재설치 시에도 데이터와 툴을 보호하기 위해 물리적/논리적 파티션 분리는 필수입니다.</p>
      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>/ (Root)</span>
          <span style="font-size: 0.9em; opacity: 0.8;">OS 시스템 영역. 50GB~100GB 권장.</span>
        </div>
        <div class="shortcut-card">
          <span>/tools</span>
          <span style="font-size: 0.9em; opacity: 0.8;">EDA 툴 설치 경로. OS와 완전히 분리 필수.</span>
        </div>
        <div class="shortcut-card">
          <span>/home</span>
          <span style="font-size: 0.9em; opacity: 0.8;">사용자 데이터. 백업 1순위.</span>
        </div>
        <div class="shortcut-card">
          <span>SWAP</span>
          <span style="font-size: 0.9em; opacity: 0.8;">PHY 합성 시 RAM 부족 대비. RAM 용량의 0.5배 이상.</span>
        </div>
      </div>

      <h2>2. 필수 의존성 패키지 (Ghost Libraries)</h2>
      <p>최신 OS(Rocky 9)에 이전 세대 EDA 툴을 설치할 때 발생하는 라이브러리 에러 해결책입니다.</p>
      <pre><code class="language-bash"># 1. EPEL 저장소 활성화
sudo dnf install -y epel-release

# 2. 필수 시스템 라이브러리 & 개발 툴
sudo dnf groupinstall -y "Development Tools"
sudo dnf install -y redhat-lsb-core git wget htop

# 3. EDA 툴 구동을 위한 Legacy 라이브러리 (Crucial!)
# libnsl: FlexLM 라이센스 데몬이 주로 사용
# libX*: Vivado/Questasim GUI 구동용
sudo dnf install -y libnsl libX11 libXext libXft libXtst \
    ncurses-compat-libs \
    libstdc++.i686 glibc.i686</code></pre>

      <div class="note-box">
        <i data-lucide="alert-triangle"></i>
        <div>
          <strong>주의: SELinux 및 방화벽</strong><br>
          FlexLM 라이센스 서버 통신 문제 해결을 위해, 내부망일 경우 SELinux는 <code>Permissive</code>로, 방화벽은 특정 포트(27000~27009)를 개방하거나 비활성화해야
          할 수 있습니다.
        </div>
      </div>

      <h2>3. Environment Modules (Best Practice)</h2>
      <p>여러 버전의 툴(Vivado 2022, 2024 등)을 <code>.bashrc</code>에 다 넣으면 충돌납니다. <strong>Module</strong> 시스템을 사용하세요.</p>

      <pre><code class="language-bash"># 설치
sudo dnf install -y environment-modules</code></pre>

      <p>설치 후 사용자는 필요한 버전만 로드해서 깔끔하게 사용 가능합니다.</p>
      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>사용 가능 툴 확인</span>
          <span class="kbd-group">module avail</span>
        </div>
        <div class="shortcut-card">
          <span>툴 로드</span>
          <span class="kbd-group">module load vivado/2023.2</span>
        </div>
        <div class="shortcut-card">
          <span>툴 언로드</span>
          <span class="kbd-group">module unload vivado</span>
        </div>
      </div>

      <h3 style="margin-top:20px;">Modulefile 작성 예시 (/usr/share/Modules/modulefiles/vivado/2023.2)</h3>
      <pre><code class="language-tcl">#%Module1.0
proc ModulesHelp { } {
    puts stderr "Sets up the environment for Vivado 2023.2"
}

set basedir /tools/Xilinx/Vivado/2023.2
prepend-path PATH $basedir/bin
setenv XILINX_VIVADO $basedir</code></pre>

      <h2>4. 다중 사용자 권한 관리 노하우</h2>
      <p>서버 관리자가 매번 권한을 수정해주지 않으려면 초기 그룹 설정이 중요합니다.</p>
      <ul style="list-style: disc; margin-left: 20px; line-height: 1.8;">
        <li><strong>EDA 그룹 생성:</strong> 모든 엔지니어를 <code>eda_users</code> 그룹에 포함.</li>
        <li><strong>SetGID 비트 설정:</strong> 프로젝트 폴더에 <code>chmod g+s</code>를 걸면, 누가 파일을 생성하든 그룹 권한이 상속되어 서로 수정 가능합니다.
        </li>
        <li><strong>umask 설정:</strong> <code>/etc/bashrc</code> 또는 <code>/etc/profile</code>에 <code>umask 002</code>를
          설정하여 그룹 멤버 간 쓰기 권한을 기본 허용합니다.</li>
      </ul>
    </section>

    <!-- SERVER OPS SECTION -->
    <section id="server-ops" class="content-section">
      <h1>Server & User Management</h1>
      <p>여러 엔지니어가 사용하는 시뮬레이션 서버를 관리하기 위한 필수 명령어입니다.</p>

      <h2>1. 사용자 추가 및 그룹 관리</h2>
      <pre><code class="language-bash"># EDA 그룹 생성
sudo groupadd eda_users

# 사용자 생성 (홈 디렉토리 포함, bash 쉘 사용, 그룹 지정)
sudo useradd -m -g eda_users -s /bin/bash engineer01

# 비밀번호 설정
sudo passwd engineer01</code></pre>

      <h2>2. 데이터 및 툴 디렉토리 권한</h2>
      <p>EDA 툴은 보통 <code>/tools</code> 또는 <code>/opt</code>에 설치하며, 공용 라이브러리는 읽기 전용으로 관리합니다.</p>
      <pre><code class="language-bash"># 디렉토리 생성
sudo mkdir -p /tools/xilinx /tools/mentor

# 소유권 변경 (관리자: root, 그룹: eda_users)
sudo chown -R root:eda_users /tools

# 권한 설정 (소유자: RWX, 그룹: RX, 기타: RX)
sudo chmod -R 755 /tools</code></pre>
      <h2>3. 파일 관리 및 압축 (Archiving)</h2>
      <p>프로젝트 백업 및 대용량 시뮬레이션 데이터 이동 시 필수적인 명령어입니다.</p>

      <h3>파일 복사 및 이동</h3>
      <pre><code class="language-bash"># 디렉토리 통째로 복사 (-r: recursive, -p: 권한 보존, -v: 상세 출력)
cp -rpv project_v1 project_v1_backup

# 파일 이동 및 이름 변경
mv old_name.v new_name.v
mv *.v ../backup/</code></pre>

      <h3>압축 및 해제 (tar)</h3>
      <p>Linux에서는 주로 <code>tar.gz</code> 형식을 사용합니다. 옵션 순서(czvf)를 외워두면 편합니다.</p>
      <div class="note-box">
        <i data-lucide="package"></i>
        <div>
          <strong>핵심 옵션:</strong>
          <ul style="list-style: disc; margin-left: 20px; margin-top: 5px;">
            <li><strong>c</strong>: Create (압축 생성)</li>
            <li><strong>x</strong>: Extract (압축 해제)</li>
            <li><strong>z</strong>: gzip 압축 사용</li>
            <li><strong>v</strong>: Verbose (과정 출력)</li>
            <li><strong>f</strong>: File (파일명 지정, 항상 마지막에 위치)</li>
          </ul>
        </div>
      </div>

      <pre><code class="language-bash"># 프로젝트 압축하기 (현재 디렉토리의 projectA 폴더를 archive.tar.gz로)
tar -czvf archive.tar.gz ./projectA

# 압축 해제하기
tar -xzvf archive.tar.gz

# 특정 디렉토리에 풀기 (-C 옵션)
tar -xzvf archive.tar.gz -C /data/restore/</code></pre>
    </section>

    <!-- FPGA WORKFLOW SECTION (Questasim & Make) -->
    <section id="fpga-workflow" class="content-section">
      <h1>FPGA Simulation Workflow</h1>
      <p>FPGA 개발의 꽃은 시뮬레이션입니다. Questasim과 Vivado를 리눅스 터미널(Makefile)에서 제어하는 방법을 마스터하세요.</p>

      <h2>1. Questasim Makefile 완벽 분석</h2>
      <p>단순히 복사해서 쓰는 것이 아니라, 각 명령어의 의미를 이해해야 에러를 잡을 수 있습니다.</p>

      <div class="note-box">
        <i data-lucide="book-open"></i>
        <div>
          <strong>핵심 명령어 설명:</strong>
          <ul style="list-style: disc; margin-left: 20px; margin-top: 10px;">
            <li><code>vlib work</code>: 컴파일된 디자인 유닛들이 저장될 물리적인 디렉토리를 생성합니다.</li>
            <li><code>vmap work work</code>: 논리적인 라이브러리 이름(work)을 물리적 디렉토리에 매핑합니다.</li>
            <li><code>vlog</code>: Verilog/SystemVerilog 컴파일러. <code>+incdir+</code> 옵션으로 헤더 파일 경로를 지정하는 것이 필수입니다.</li>
            <li><code>vopt</code>: <strong>Visualizer 최적화</strong>. <code>-o opt -debug +designfile</code> 옵션으로 디버그 정보가
              포함된 최적화 객체를 생성합니다.</li>
            <li><code>vsim</code>: <code>-qwavedb=+signal</code> 옵션을 사용하여 Visualizer용 고속 시뮬레이션 DB를 생성합니다.</li>
          </ul>
        </div>
      </div>

      <pre><code class="language-makefile"># Makefile for Questasim (Visualizer Flow)
RTL_DIR = ../src
TB_DIR  = ../tb
WORK    = work
RTL_LIST = ../sim/run.f
TOP     = tb_top
OPT     = opt

# Visualizer GUI Live Simulation (with QWaveDB)
gui: clean compiled optimize
	vsim $(OPT) -visualizer -qwavedb=+signal -do "run 10 us"

# Batch / Post simulation mode
sim: clean compiled optimize
	vsim -batch $(OPT) -qwavedb=+signal -do "run -all; quit"

optimize:
	# vopt: Optimize & Debug options (+designfile for Visualizer)
	vopt $(WORK).$(TOP) -o $(OPT) -debug +designfile -L $(WORK)

compiled:
	vlib $(WORK)
	vmap work $(WORK)
	vlog -work $(WORK) +incdir+$(RTL_DIR) -f $(RTL_LIST)
	vlog -work $(WORK) +incdir+$(TB_DIR) $(TB_DIR)/$(TOP).v

clean:
	rm -rf $(WORK) transcript vsim.wlf qwave.db visualizer.log</code></pre>

      <div class="note-box">
        <i data-lucide="file-text"></i>
        <div>
          <strong>run.f 파일 예시:</strong><br />
          와일드카드(*.v)는 파일 로드 순서를 보장하지 않습니다. 상위 모듈이 하위 모듈보다 먼저 오지 않도록, 파일 리스트에서 의존성 순서대로 명시하는 것이 정석입니다.
          <pre><code class="language-plaintext" style="margin-top: 10px; background: #000; padding: 10px;">// 주석 가능
../src/defines.v
../src/alu.v
../src/cpu_top.v
</code></pre>
        </div>
      </div>

      <h2>2. Vivado 배포/합성 자동화 (Batch Mode)</h2>
      <p>Vivado에서도 파일 리스트(sources.f)를 Tcl로 파싱하여 관리하는 것이 유지보수에 좋습니다.</p>
      <pre><code class="language-makefile"># Makefile for Vivado
bitstream: 
	vivado -mode batch -source run_synth.tcl</code></pre>

      <h3>예시: run_synth.tcl (파일 리스트 읽기)</h3>
      <pre><code class="language-tcl"># run_synth.tcl
create_project -in_memory -part xc7a35ticsg324-1L

# 파일 리스트 읽기 함수
set fp [open "sources.f" r]
set file_data [read $fp]
close $fp

# 라인별로 읽어서 read_verilog 실행
foreach line [split $file_data "\n"] {
    # 빈 줄이나 주석(#) 제외
    if {[string length $line] > 0 && ![string match "#*" $line]} {
        read_verilog $line
    }
}

read_xdc ../const/pins.xdc

synth_design -top top_module -part xc7a35ticsg324-1L
opt_design
place_design
route_design
write_bitstream -force ./build_output/final.bit</code></pre>
    </section>

    <!-- VIM MASTERY SECTION -->
    <section id="vim-mastery" class="content-section">
      <h1>VIM Mastery: Pro Level</h1>
      <p>기본 이동을 넘어서, 코딩 속도를 2배로 올려줄 고급 기능들입니다.</p>

      <h2>1. 파일 조작 및 쉘 전환 (File Ops & Shell)</h2>
      <p>가장 기초적인 파일 열기, 저장, 종료 방법과 작업 중 잠시 쉘로 나가는 방법입니다.</p>

      <h3>파일 열기 및 저장/종료</h3>
      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>파일 열기</span>
          <span class="kbd-group"><span class="key">vim</span><span>파일명</span></span>
        </div>
        <div class="shortcut-card">
          <span>저장하기</span>
          <span class="kbd-group"><span class="key">:</span><span>w</span></span>
        </div>
        <div class="shortcut-card">
          <span>저장하고 종료</span>
          <span class="kbd-group"><span class="key">:</span><span>wq</span></span>
        </div>
        <div class="shortcut-card">
          <span>강제 종료 (저장X)</span>
          <span class="kbd-group"><span class="key">:</span><span>q!</span></span>
        </div>
      </div>

      <h3>잠시 쉘로 나가기 (Suspend/Foreground)</h3>
      <p>편집기를 끄지 않고 터미널 명령어를 써야 할 때(예: git status, 파일 목록 확인) 유용합니다.</p>
      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>작업 일시 중단 (Suspend)</span>
          <span class="kbd-group"><span class="key">Ctrl</span>+<span class="key">z</span></span>
        </div>
        <div class="shortcut-card">
          <span>편집기 복귀 (Foreground)</span>
          <span class="kbd-group"><span class="key">fg</span></span>
        </div>
      </div>

      <h2>2. 다중 창 활용 (Window Splits)</h2>
      <p>Testbench와 RTL 코드를 동시에 띄워놓고 비교할 때 필수입니다.</p>
      <div class="shortcut-grid">
        <div class="shortcut-card">
          <span>세로 분할 (Vertical Split)</span>
          <span class="kbd-group"><span class="key">:</span><span>vsp 파일명</span></span>
        </div>
        <div class="shortcut-card">
          <span>가로 분할 (Horizontal Split)</span>
          <span class="kbd-group"><span class="key">:</span><span>sp 파일명</span></span>
        </div>
        <div class="shortcut-card">
          <span>창 간 이동</span>
          <span class="kbd-group"><span class="key">Ctrl</span>+<span class="key">w</span>, <span
              class="key">w</span></span>
        </div>
        <div class="shortcut-card">
          <span>현재 창 닫기</span>
          <span class="kbd-group"><span class="key">:</span><span>q</span></span>
        </div>
      </div>

      <h2>3. 검색 및 일괄 치환 (Search & Replace)</h2>
      <p>변수명을 한 번에 바꿀 때 유용합니다. Verilog 리팩토링의 핵심입니다.</p>
      <pre><code class="language-bash"># 기본 검색 (Normal Mode)
/clk_en      # 아래로 'clk_en' 검색
?reset_n     # 위로 'reset_n' 검색
n / N        # 다음 / 이전 찾기

# 단어 바로 찾기
*            # 커서가 위치한 단어를 즉시 검색

# 치환 (Substitute)
# 문법: :[범위]s/찾을단어/바꿀단어/[플래그]

# 1. 파일 전체 치환 ('%'는 전체 파일을 의미)
:%s/wire/reg/g       # 파일의 첫 줄부터 끝 줄까지 모든 'wire' 변경

# 2. 현재 줄만 치환 ('%' 생략 시 커서가 있는 줄만 대상)
:s/wire/reg/g        # 현재 커서가 있는 줄의 'wire'만 변경

# 3. 특정 범위 지정
:10,20s/wire/reg/g   # 10번 줄부터 20번 줄까지만 변경

# Tip: 'g' (global) 플래그를 빼면 각 줄의 첫 번째 일치 항목만 바뀝니다.
# :%s/old/new        # (각 줄의 첫 번째 'old'만 'new'로 변경)</code></pre>

      <h2>4. 매크로 (Macros): 반복 작업 자동화</h2>
      <p>규칙적인 노가다성 코드 수정(예: 100개의 포트 연결)을 자동화합니다.</p>
      <ol style="margin-left: 20px; line-height: 2;">
        <li><strong>녹화 시작:</strong> Normal Mode에서 <span class="key">q</span> 누르고 레지스터 키(예: <span class="key">a</span>)
          누름 &rarr; 상태바에 <code>recording @a</code> 표시됨.</li>
        <li><strong>작업 수행:</strong> 반복할 작업을 1회 수행 (예: 줄 끝에 콤마 찍고 아래로 이동).</li>
        <li><strong>녹화 종료:</strong> <span class="key">q</span> 다시 누름.</li>
        <li><strong>실행:</strong> <span class="key">@</span><span class="key">a</span> (1회 실행) 또는 <span
            class="key">100</span><span class="key">@</span><span class="key">a</span> (100회 반복).</li>
      </ol>

      <h2>5. .vimrc 설정 (엔지니어 필수)</h2>
      <p>홈 디렉토리의 <code>~/.vimrc</code> 파일에 아래 내용을 추가하여 가독성을 높이세요.</p>
      <pre><code class="language-plaintext">" 문법 강조
syntax on

" 줄 번호 표시
set number

" 자동 들여쓰기 (Verilog 코딩 시 필수)
set autoindent
set cindent

" 탭 대신 스페이스 4칸 사용 (팀 코딩 컨벤션)
set expandtab
set tabstop=4
set shiftwidth=4

" 검색 시 대소문자 무시하되, 대문자 섞이면 구분
set ignorecase
set smartcase

" 괄호 짝 찾기 하이라이트
set showmatch</code></pre>
    </section>

  </main>

  <div class="status-bar">
    <span>MODE: NORMAL</span>
    <span>pos: 1,1</span>
    <span>file: linux_lect_v1.0</span>
  </div>

  <script type="module" src="/src/main.js"></script>
</body>

</html>